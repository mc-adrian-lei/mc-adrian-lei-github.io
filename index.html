<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>32 Aspect Developmental Self Clock — Mind–Body–Energy Mapping</title>
  <style>
    /* =============================================================
       32 Aspect Developmental Self Clock — Single File Implementation
       • Plain HTML, CSS, and JavaScript (no external libraries)
       • Accessible controls + Canvas visualization
       • Keyboard navigation, high-contrast defaults, mobile-friendly
       ============================================================= */

    :root {
      color-scheme: light;
      --bg: #f6f7fc;
      --bg-soft: rgba(255, 255, 255, 0.95);
      --panel: rgba(255, 255, 255, 0.9);
      --panel-strong: rgba(255, 255, 255, 0.98);
      --ink: #101327;
      --muted: #5d6786;
      --accent: #1d4ed8;
      --accent-2: #7c3aed;
      --good: #059669;
      --warn: #d97706;
      --bad: #dc2626;
      --ring-line-1: rgba(79, 70, 229, 0.2);
      --ring-line-2: rgba(59, 130, 246, 0.18);
      --stage-line: rgba(37, 99, 235, 0.28);
      --node-label: rgba(28, 35, 64, 0.82);
      --focus: #facc15;
      --input-bg: rgba(248, 249, 255, 0.95);
      --input-border: rgba(148, 163, 233, 0.35);
      --input-border-focus: rgba(37, 99, 235, 0.55);
      --shadow-1: 0 18px 32px rgba(15, 23, 42, 0.12);
      --shadow-2: 0 24px 60px rgba(15, 23, 42, 0.18);
      --glass-stroke: rgba(148, 163, 233, 0.22);
    }

    body[data-theme="dark"] {
      color-scheme: dark;
      --bg: #050914;
      --bg-soft: #0b1230;
      --panel: rgba(18, 22, 45, 0.85);
      --panel-strong: rgba(17, 25, 56, 0.92);
      --ink: #f5f7ff;
      --muted: #b4bcdd;
      --accent: #60a5fa;
      --accent-2: #a855f7;
      --good: #34d399;
      --warn: #fbbf24;
      --bad: #f87171;
      --ring-line-1: rgba(88, 119, 255, 0.22);
      --ring-line-2: rgba(37, 58, 123, 0.28);
      --stage-line: rgba(124, 196, 255, 0.35);
      --node-label: rgba(226, 234, 255, 0.95);
      --input-bg: rgba(20, 26, 53, 0.75);
      --input-border: rgba(102, 126, 234, 0.35);
      --input-border-focus: rgba(144, 160, 255, 0.75);
      --shadow-1: 0 18px 40px rgba(3, 7, 18, 0.45);
      --shadow-2: 0 20px 60px rgba(5, 11, 32, 0.65);
      --glass-stroke: rgba(120, 150, 255, 0.18);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Roboto", "Helvetica Neue", sans-serif;
      background:
        radial-gradient(1200px 1200px at 72% 12%, rgba(125, 211, 252, 0.24), transparent),
        radial-gradient(1000px 1000px at 15% 85%, rgba(196, 181, 253, 0.18), transparent),
        linear-gradient(170deg, var(--bg-soft), var(--bg));
      color: var(--ink);
      transition: background 0.6s ease, color 0.4s ease;
    }

    body[data-theme="dark"] {
      background:
        radial-gradient(900px 900px at 85% 18%, rgba(59, 130, 246, 0.18), transparent),
        radial-gradient(720px 720px at 12% 88%, rgba(129, 140, 248, 0.18), transparent),
        linear-gradient(160deg, rgba(9, 12, 28, 0.92), var(--bg));
    }

    .app {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 360px;
      grid-template-rows: auto 1fr auto;
      grid-template-areas:
        "top top"
        "vis side"
        "footer footer";
      gap: 16px;
      height: 100dvh;
      padding: clamp(16px, 2vw, 28px);
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      grid-area: top;
      display: flex;
      flex-direction: column;
      gap: 14px;
      background: var(--panel);
      border: 1px solid var(--glass-stroke);
      border-radius: 20px;
      padding: clamp(16px, 2vw, 24px);
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow-1);
    }

    .header-top {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    header h1 {
      font-size: clamp(18px, 2.4vw, 26px);
      margin: 0;
      letter-spacing: 0.4px;
    }

    .title-block { max-width: min(640px, 100%); }

    .subtitle {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: clamp(12px, 1.6vw, 14px);
      max-width: 60ch;
    }

    .mode-toggle {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .control-cluster {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .control-cluster.secondary { margin-left: auto; justify-content: flex-end; }

    button { font: inherit; }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 12px;
      border: 1px solid color-mix(in srgb, var(--accent) 40%, transparent);
      background: linear-gradient(140deg,
        color-mix(in srgb, var(--accent) 35%, transparent) 0%,
        color-mix(in srgb, var(--accent-2) 32%, transparent) 100%);
      color: var(--ink);
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.18);
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 16px 36px rgba(59, 130, 246, 0.28); }
    .btn:active { transform: translateY(0); }
    .btn:focus-visible { outline: 3px solid var(--focus); outline-offset: 2px; }
    .btn.secondary {
      background: color-mix(in srgb, var(--panel-strong) 92%, transparent);
      border-color: color-mix(in srgb, var(--accent) 25%, transparent);
      box-shadow: none;
    }
    .btn.secondary:hover { background: color-mix(in srgb, var(--panel-strong) 75%, var(--accent) 25%); }
    .btn.warn {
      background: color-mix(in srgb, var(--bad) 45%, transparent 55%);
      border-color: color-mix(in srgb, var(--bad) 60%, transparent);
      box-shadow: none;
    }
    .btn.warn:hover { background: color-mix(in srgb, var(--bad) 60%, transparent 40%); }
    .btn.ghost {
      background: transparent;
      border-color: color-mix(in srgb, var(--muted) 26%, transparent);
      color: var(--muted);
      box-shadow: none;
    }
    .btn.ghost:hover { color: var(--ink); border-color: color-mix(in srgb, var(--accent) 40%, transparent); }
    .btn.tertiary {
      background: color-mix(in srgb, var(--accent) 18%, transparent);
      border-color: color-mix(in srgb, var(--accent) 35%, transparent);
      color: var(--ink);
      box-shadow: none;
    }
    .btn.small { padding: 6px 12px; font-size: 12px; }

    .desktop-only {}
    .mobile-only { display: none !important; }

    body[data-layout="mobile"] .desktop-only { display: none !important; }
    body[data-layout="mobile"] .mobile-only { display: revert !important; }

    .vis {
      grid-area: vis;
      position: relative;
      background: linear-gradient(165deg,
        color-mix(in srgb, var(--panel-strong) 92%, transparent) 0%,
        color-mix(in srgb, var(--bg) 75%, transparent) 100%);
      border-radius: 24px;
      border: 1px solid var(--glass-stroke);
      display: grid;
      grid-template-rows: 1fr auto;
      overflow: clip;
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-2);
    }

    canvas { width: 100%; height: 100%; display: block; }

    .legend {
      padding: 16px;
      border-top: 1px solid color-mix(in srgb, var(--accent) 22%, transparent);
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      background: color-mix(in srgb, var(--panel) 90%, transparent);
    }

    .legend .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid color-mix(in srgb, var(--accent) 25%, transparent);
      border-radius: 999px;
      padding: 6px 12px;
      color: var(--muted);
      background: color-mix(in srgb, var(--panel-strong) 85%, transparent);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .legend .swatch {
      width: 12px;
      height: 12px;
      border-radius: 4px;
      background: var(--accent);
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 50%, transparent);
      display: inline-block;
    }

    aside {
      grid-area: side;
      display: grid;
      grid-template-rows: auto auto auto 1fr auto;
      gap: 14px;
      background: var(--panel-strong);
      border: 1px solid var(--glass-stroke);
      border-radius: 22px;
      padding: 16px;
      overflow: hidden;
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow-1);
    }

    .panel {
      background: color-mix(in srgb, var(--panel) 92%, transparent);
      border: 1px solid var(--glass-stroke);
      border-radius: 18px;
      padding: 14px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      display: grid;
      gap: 10px;
    }

    .codex-suite {
      grid-column: 1 / -1;
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }

    .codex-suite .panel {
      position: relative;
      min-height: 280px;
    }

    .codex-editor h2,
    .codex-preview h2,
    .codex-docs h2 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.3px;
    }

    .codex-editor textarea,
    .codex-editor input[type="text"] {
      width: 100%;
      font: 14px/1.4 "JetBrains Mono", "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--ink);
      resize: vertical;
      min-height: 120px;
    }

    .codex-editor textarea:focus-visible,
    .codex-editor input[type="text"]:focus-visible {
      border-color: var(--input-border-focus);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent);
      outline: none;
    }

    .codex-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .visitor-feedback {
      margin-top: 6px;
      padding: 14px;
      border-radius: 16px;
      border: 1px dashed color-mix(in srgb, var(--accent) 35%, transparent);
      background: color-mix(in srgb, var(--panel-strong) 78%, transparent);
      display: grid;
      gap: 10px;
    }

    .visitor-feedback h3 {
      margin: 0;
      font-size: 15px;
      letter-spacing: 0.2px;
    }

    .visitor-label {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: color-mix(in srgb, var(--muted) 70%, var(--ink) 30%);
    }

    .visitor-message-field {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: stretch;
    }

    .visitor-message-field input[type="text"] {
      flex: 1 1 200px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--ink);
      font: 14px/1.4 "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Roboto", "Helvetica Neue", sans-serif;
      min-height: 44px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .visitor-message-field input[type="text"]:focus-visible {
      border-color: var(--input-border-focus);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent);
      outline: none;
    }

    .visitor-message-field button {
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .visitor-status {
      min-height: 18px;
      font-size: 12px;
      color: var(--muted);
    }

    .visitor-status[data-state="success"] {
      color: color-mix(in srgb, var(--good) 75%, var(--ink) 25%);
    }

    .visitor-status[data-state="error"] {
      color: color-mix(in srgb, var(--bad) 78%, var(--ink) 22%);
    }

    .codex-status {
      flex: 1 1 220px;
      min-height: 44px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent);
      background: color-mix(in srgb, var(--panel) 88%, transparent);
      font-size: 13px;
      line-height: 1.4;
    }

    .codex-status[data-state="error"] {
      border-color: color-mix(in srgb, var(--bad) 50%, transparent);
      background: color-mix(in srgb, var(--bad) 12%, transparent);
      color: color-mix(in srgb, var(--bad) 80%, black);
    }

    .codex-status[data-state="success"] {
      border-color: color-mix(in srgb, var(--good) 50%, transparent);
      background: color-mix(in srgb, var(--good) 12%, transparent);
      color: color-mix(in srgb, var(--good) 80%, black);
    }

    .codex-preview iframe {
      width: 100%;
      border: 1px solid var(--glass-stroke);
      border-radius: 14px;
      min-height: 260px;
      background: color-mix(in srgb, var(--panel) 85%, transparent);
    }

    .codex-preview iframe:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 3px;
    }

    .prompt-wrapper {
      position: relative;
    }

    .prompt-wrapper textarea {
      min-height: 90px;
    }

    .suggestions {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 4px);
      display: grid;
      gap: 4px;
      padding: 8px;
      margin: 0;
      list-style: none;
      border-radius: 12px;
      border: 1px solid var(--glass-stroke);
      background: color-mix(in srgb, var(--panel-strong) 96%, transparent);
      box-shadow: var(--shadow-1);
      max-height: 220px;
      overflow-y: auto;
      z-index: 20;
    }

    .suggestions[hidden] { display: none; }

    .suggestions button {
      background: none;
      border: 1px solid transparent;
      border-radius: 10px;
      padding: 8px 10px;
      text-align: left;
      font: inherit;
      color: inherit;
      cursor: pointer;
      transition: border-color 0.18s ease, background 0.18s ease;
    }

    .suggestions button:hover,
    .suggestions button:focus-visible {
      border-color: color-mix(in srgb, var(--accent) 40%, transparent);
      background: color-mix(in srgb, var(--accent) 14%, transparent);
      outline: none;
    }

    .codex-docs ol {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .codex-docs li strong { color: var(--ink); }

    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }

    .metric {
      background: linear-gradient(150deg,
        color-mix(in srgb, var(--panel-strong) 92%, transparent) 0%,
        color-mix(in srgb, var(--accent) 18%, transparent) 100%);
      border: 1px solid color-mix(in srgb, var(--accent) 32%, transparent);
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: 6px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
    }
    .metric h3 { margin: 0; font-size: 12px; color: var(--muted); font-weight: 600; letter-spacing: 0.3px; }
    .metric .val { font-size: 20px; font-weight: 700; line-height: 1.2; color: var(--ink); }
    .metric .val small { display: block; font-size: 11px; font-weight: 500; color: var(--muted); }
    .status-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .status-label { font-size: 11px; color: var(--muted); font-weight: 600; }

    .panel p { margin: 0; }

    .scroll { overflow: auto; min-height: 120px; max-height: 50vh; padding-right: 6px; }
    .aspect-list { display: grid; gap: 10px; }

    .aspect-item {
      background: color-mix(in srgb, var(--panel-strong) 90%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent) 22%, transparent);
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: 10px;
      transition: transform 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
    }
    .aspect-item:hover { transform: translateY(-2px); border-color: color-mix(in srgb, var(--accent) 45%, transparent); box-shadow: 0 12px 26px rgba(37, 99, 235, 0.18); }
    .aspect-item[aria-selected="true"] { border-color: color-mix(in srgb, var(--focus) 60%, transparent); box-shadow: 0 16px 32px rgba(253, 230, 138, 0.28); }

    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .row .name { display: inline-flex; align-items: center; gap: 8px; font-weight: 700; font-size: 14px; letter-spacing: 0.25px; }

    .badge {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      background: color-mix(in srgb, var(--panel) 80%, transparent);
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid color-mix(in srgb, var(--accent) 20%, transparent);
    }

    .dot { width: 12px; height: 12px; border-radius: 999px; box-shadow: 0 0 0 2px rgba(255,255,255,0.05); }

    }
    .metric h3 { margin: 0; font-size: 12px; color: var(--muted); font-weight: 600; letter-spacing: 0.3px; }
    .metric .val { font-size: 20px; font-weight: 700; line-height: 1.2; color: var(--ink); }
    .metric .val small { display: block; font-size: 11px; font-weight: 500; color: var(--muted); }

    .panel p { margin: 0; }

    .scroll { overflow: auto; min-height: 120px; max-height: 50vh; padding-right: 6px; }
    .aspect-list { display: grid; gap: 10px; }

    .aspect-item {
      background: color-mix(in srgb, var(--panel-strong) 90%, transparent);
      border: 1px solid color-mix(in srgb, var(--accent) 22%, transparent);
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: 10px;
      transition: transform 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
    }
    .aspect-item:hover { transform: translateY(-2px); border-color: color-mix(in srgb, var(--accent) 45%, transparent); box-shadow: 0 12px 26px rgba(37, 99, 235, 0.18); }
    .aspect-item[aria-selected="true"] { border-color: color-mix(in srgb, var(--focus) 60%, transparent); box-shadow: 0 16px 32px rgba(253, 230, 138, 0.28); }

    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .row .name { display: inline-flex; align-items: center; gap: 8px; font-weight: 700; font-size: 14px; letter-spacing: 0.25px; }

    .badge {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      background: color-mix(in srgb, var(--panel) 80%, transparent);
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid color-mix(in srgb, var(--accent) 20%, transparent);
    }

    .dot { width: 12px; height: 12px; border-radius: 999px; box-shadow: 0 0 0 2px rgba(255,255,255,0.05); }

    .activation-bar { position: relative; width: 100%; height: 6px; border-radius: 999px; background: color-mix(in srgb, var(--panel) 82%, transparent); overflow: hidden; }
    .activation-bar span { display: block; height: 100%; border-radius: inherit; background: linear-gradient(90deg, rgba(125, 211, 252, 0.85), rgba(168, 85, 247, 0.9)); transition: width 0.2s ease; }

    .tags { display: flex; gap: 6px; flex-wrap: wrap; }
    .tag { font-size: 11px; color: var(--muted); background: color-mix(in srgb, var(--panel-strong) 88%, transparent); border: 1px solid color-mix(in srgb, var(--accent) 18%, transparent); padding: 3px 8px; border-radius: 999px; letter-spacing: 0.2px; }

    label { font-size: 12px; color: var(--muted); font-weight: 600; }

    input[type="range"] { width: 100%; accent-color: var(--accent); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(255,255,255,0.4); box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 50%, transparent); cursor: pointer; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; border-radius: 999px; background: color-mix(in srgb, var(--panel) 80%, transparent); }
    input[type="range"]:focus-visible { outline: 2px solid var(--focus); outline-offset: 2px; }

    .input-field { display: grid; gap: 6px; }
    .input-field input,
    .input-field select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      padding: 9px 12px;
      color: var(--ink);
      font: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .input-field input::placeholder { color: color-mix(in srgb, var(--muted) 65%, transparent); }
    .input-field input:focus-visible,
    .input-field select:focus-visible { border-color: var(--input-border-focus); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent); outline: none; }

    .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; }


    .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; }

    .toggle { display: inline-flex; align-items: center; gap: 10px; font-size: 12px; color: var(--muted); font-weight: 600; }
    .toggle input { position: relative; width: 44px; height: 24px; border-radius: 999px; background: color-mix(in srgb, var(--panel) 80%, transparent); border: 1px solid var(--input-border); cursor: pointer; appearance: none; transition: background 0.2s ease, border-color 0.2s ease; }
    .toggle input::after { content: ''; position: absolute; top: 3px; left: 3px; width: 18px; height: 18px; border-radius: 50%; background: var(--muted); transition: transform 0.2s ease, background 0.2s ease; }
    .toggle input:checked { background: color-mix(in srgb, var(--accent) 45%, transparent); border-color: color-mix(in srgb, var(--accent) 60%, transparent); }
    .toggle input:checked::after { transform: translateX(20px); background: var(--ink); }

    .filter-actions { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .filter-actions .btn { box-shadow: none; }

    .empty-state { text-align: center; color: var(--muted); font-size: 13px; padding: 20px; border: 1px dashed color-mix(in srgb, var(--accent) 30%, transparent); border-radius: 14px; }

    footer {
      grid-area: footer;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      background: color-mix(in srgb, var(--panel) 90%, transparent);
      border: 1px solid var(--glass-stroke);
      padding: 12px 16px;
      border-radius: 18px;
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow-1);
    }

    .vis-hint { color: var(--muted); font-size: 12px; }

    .panel-overlay {
      display: none;
    }

    .comparison-summary {
      background: color-mix(in srgb, var(--panel-strong) 85%, transparent);
      border: 1px dashed color-mix(in srgb, var(--accent) 30%, transparent);
      border-radius: 14px;
      padding: 12px;
      font-size: 12px;
      color: var(--muted);
    }

    dialog {
      border: none;
      border-radius: 20px;
      padding: 0;
      max-width: min(540px, 90vw);
      background: var(--panel-strong);
      color: var(--ink);
      box-shadow: var(--shadow-2);
    }
    dialog::backdrop { background: rgba(15, 23, 42, 0.45); }

    dialog .modal-body {
      display: grid;
      gap: 14px;
      padding: 20px;
      background: transparent;
    }

    .tutorial-list { padding-left: 18px; display: grid; gap: 8px; font-size: 13px; color: var(--muted); }
    .tutorial-list li strong { color: var(--ink); }

    .export-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }

    body[data-layout="mobile"] {
      padding-bottom: env(safe-area-inset-bottom, 0px);
    }

    body[data-layout="mobile"] .app {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: auto;
      min-height: 100dvh;
    }

    body[data-layout="mobile"] header {
      position: sticky;
      top: 0;
      z-index: 60;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
    }

    body[data-layout="mobile"] .vis {
      min-height: 360px;
    }

    body[data-layout="mobile"] aside {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      max-height: 86dvh;
      transform: translateY(100%);
      transition: transform 0.32s ease, box-shadow 0.32s ease;
      border-radius: 24px 24px 0 0;
      box-shadow: 0 -18px 46px rgba(15, 23, 42, 0.16);
      z-index: 55;
      overflow-y: auto;
      overscroll-behavior: contain;
    }

    body[data-layout="mobile"] .panel {
      background: color-mix(in srgb, var(--panel) 96%, transparent);
    }

    body[data-layout="mobile"][data-panel="open"] aside {
      transform: translateY(0%);
      box-shadow: 0 -24px 60px rgba(15, 23, 42, 0.22);
    }

    body[data-layout="mobile"] .panel-overlay {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: block;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.32s ease;
      background: rgba(15, 23, 42, 0.25);
      backdrop-filter: blur(6px);
    }


    body[data-layout="mobile"] .app {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: auto;
      min-height: 100dvh;
    }

    body[data-layout="mobile"] header {
      position: sticky;
      top: 0;
      z-index: 60;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
    }

    body[data-layout="mobile"] .vis {
      min-height: 360px;
    }

    body[data-layout="mobile"] aside {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      max-height: 86dvh;
      transform: translateY(100%);
      transition: transform 0.32s ease, box-shadow 0.32s ease;
      border-radius: 24px 24px 0 0;
      box-shadow: 0 -18px 46px rgba(15, 23, 42, 0.16);
      z-index: 55;
      overflow-y: auto;
      overscroll-behavior: contain;
    }

    body[data-layout="mobile"] .panel {
      background: color-mix(in srgb, var(--panel) 96%, transparent);
    }

    body[data-layout="mobile"][data-panel="open"] aside {
      transform: translateY(0%);
      box-shadow: 0 -24px 60px rgba(15, 23, 42, 0.22);
    }

    body[data-layout="mobile"] .panel-overlay {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: block;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.32s ease;
      background: rgba(15, 23, 42, 0.25);
      backdrop-filter: blur(6px);
    }

    body[data-layout="mobile"][data-panel="open"] .panel-overlay {
      opacity: 1;
      pointer-events: auto;
    }

    body[data-layout="mobile"] footer {
      padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    }

    dialog {
      border: 1px solid var(--glass-stroke);
      border-radius: 20px;
      padding: 0;
      color: var(--ink);
      background: var(--panel-strong);
      max-width: min(540px, 92vw);
      box-shadow: var(--shadow-2);
      backdrop-filter: blur(18px);
    }
    dialog::backdrop { background: rgba(0,0,0,.45); }
    .modal-head { padding: 16px; border-bottom: 1px solid color-mix(in srgb, var(--accent) 25%, transparent); display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .modal-body { padding: 16px; display: grid; gap: 12px; }
    .modal-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; }
    .modal-grid > div { background: color-mix(in srgb, var(--panel) 90%, transparent); border: 1px solid var(--glass-stroke); border-radius: 14px; padding: 10px; }
    .modal-body .panel { box-shadow: none; }

    @media (max-width: 1200px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-areas: "top" "vis" "side" "footer";
        height: auto;
        min-height: 100dvh;
      }
    }

    @media (max-width: 860px) {
      .control-row { flex-direction: column; align-items: flex-start; gap: 12px; }
      .control-cluster { width: 100%; }
      .control-cluster .btn { flex: 1 1 auto; justify-content: center; }
      footer { justify-content: center; text-align: center; }
    }

    @media (max-width: 640px) {
      header { padding: 16px; }
      .legend { gap: 8px; }
      .legend .chip { padding: 6px 10px; }
      aside { padding: 14px; }
    }
  </style>
</head>
<body data-layout="desktop" data-panel="open">
  <div class="app" role="application" aria-label="32 Aspect Developmental Self Clock">
    <header>
      <div class="header-top">
        <div class="title-block">
          <h1>32 Aspect Self Clock · Mind–Body–Energy Mapping</h1>
          <p class="subtitle">An interactive atlas for synchronising cognitive, somatic, and archetypal development across the lifespan.</p>
        </div>
        <div class="mode-toggle" role="group" aria-label="Model lenses">
          <button id="modeMind" class="btn" aria-pressed="true" title="View Mind model (psych/semantic)">🧠 Mind</button>
          <button id="modeBody" class="btn secondary" aria-pressed="false" title="View Body model (neuro/physiology)">🩺 Body</button>
          <button id="modeSoul" class="btn secondary" aria-pressed="false" title="View Soul model (archetypal/transpersonal)">✨ Soul</button>
          <button id="btnTheme" class="btn ghost small" type="button" aria-pressed="false" title="Toggle light or dark presentation">🌙 Dark</button>
        </div>
      </div>
      <div class="control-row">
        <div class="control-cluster">
          <button id="btnTutorial" class="btn" aria-pressed="false" title="Toggle tutorial/walkthrough mode (keyboard: T)">▶ Tutorial</button>
          <button id="btnRandomize" class="btn secondary" title="Randomize activations (keyboard: R)">Shuffle</button>
          <button id="btnDeactivate" class="btn warn" title="Set all activations to 0 (keyboard: 0)">Deactivate All</button>
        </div>
        <div class="control-cluster secondary">
          <button id="btnExport" class="btn secondary" title="Export all aspect states as JSON (keyboard: E)">Export JSON</button>
          <button id="panelToggle" class="btn ghost small mobile-only" type="button" aria-controls="insightPanel" aria-expanded="false">Insights</button>
        </div>
      </div>
    </header>

    <section class="vis">
      <canvas id="clock" aria-label="Developmental Self Clock canvas" tabindex="0"></canvas>
      <div class="legend" aria-label="Legend">
        <div class="chip"><span class="swatch" style="background: var(--accent)"></span> Stage cross-lines (12)</div>
        <div class="chip"><span class="swatch" style="background: var(--accent-2)"></span> Concentric rings (8)</div>
        <div class="chip"><span class="swatch" style="background: #34d399"></span> Resonance links (similar activation)</div>
        <div class="chip"><span class="swatch" style="background: #f59e0b"></span> Tutorial highlight</div>
      </div>
    </section>

    <aside id="insightPanel">
      <div class="panel mobile-only">
        <div class="row" style="justify-content: space-between; align-items: center;">
          <strong>Insights &amp; Controls</strong>
          <button id="panelClose" class="btn ghost small" type="button" aria-label="Close insights panel">Close</button>
        </div>
        <p class="vis-hint">Review metrics or fine-tune activations.</p>
      </div>
      <div class="panel metrics" aria-label="System metrics">
        <div class="metric" aria-live="polite">
          <h3>SCI (Semantic Coherence Index)</h3>
          <div class="val" id="sciVal">—</div>
          <div class="status-row">
            <span id="sciStatus" class="status-label">Awaiting activation data.</span>
            <button id="btnSciInfo" class="btn ghost small" type="button">What is SCI?</button>
          </div>
        </div>
        <div class="metric" aria-live="polite"><h3>Energy–Matter</h3><div class="val" id="emVal">—</div></div>
        <div class="metric" aria-live="polite"><h3>Active Aspects</h3><div class="val" id="activeVal">—</div></div>
        <div class="metric" aria-live="polite"><h3>Peak Activation</h3><div class="val" id="peakVal">—</div></div>
      </div>

      <div class="panel" aria-label="Developmental stage slider">
        <label for="devStageSlider"><strong>Developmental Stage</strong> <span id="devStageVal">1 · Infancy</span></label>
        <input id="devStageSlider" type="range" min="0" max="11" value="0" />
        <p class="vis-hint">0 = birth/infancy ··· 12 = wisdom/end-of-life · Adjusts all activations via devProfile</p>
      </div>

      <div class="panel" aria-label="Stage weighting controls">
        <div class="row" style="align-items: center; justify-content: space-between;">
          <strong>Stage Emphasis</strong>
          <button id="btnResetWeights" class="btn ghost small" type="button">Reset weights</button>
        </div>
        <label for="stageWeightSelect">Focus stage</label>
        <select id="stageWeightSelect"></select>
        <label for="stageWeightSlider">Multiplier <span id="stageWeightValue">1.00×</span></label>
        <input id="stageWeightSlider" type="range" min="0.5" max="1.8" step="0.05" value="1" />
        <p class="vis-hint">Emphasize specific stages beyond the base 0–12 developmental profile.</p>
      </div>

      <div class="panel" aria-label="Developmental comparison">
        <strong>Comparative Mode</strong>
        <div class="control-grid">
          <div class="input-field">
            <label for="compareStageA">Stage A</label>
            <select id="compareStageA"></select>
          </div>
          <div class="input-field">
            <label for="compareStageB">Stage B</label>
            <select id="compareStageB"></select>
          </div>
        </div>
        <div id="comparisonSummary" class="comparison-summary" aria-live="polite">Select two stages to compare their activation patterns.</div>
      </div>

      <div class="panel" aria-label="Aspect filters and sorting">
        <div class="control-grid">
          <div class="input-field">
            <label for="searchInput">Find aspect</label>
            <input id="searchInput" type="search" placeholder="Search names, roles, or regions" autocomplete="off" />
          </div>
          <div class="input-field">
            <label for="sortSelect">Sort by</label>
            <select id="sortSelect">
              <option value="stage">Stage · Ring</option>
              <option value="activationDesc">Activation (high → low)</option>
              <option value="activationAsc">Activation (low → high)</option>
              <option value="name">Name (A → Z)</option>
            </select>
          </div>
          <div class="input-field">
            <label for="stageFilter">Stage focus</label>
            <select id="stageFilter">
              <option value="all">All stages</option>
              <option value="1">Stage 1</option>
              <option value="2">Stage 2</option>
              <option value="3">Stage 3</option>
              <option value="4">Stage 4</option>
              <option value="5">Stage 5</option>
              <option value="6">Stage 6</option>
              <option value="7">Stage 7</option>
              <option value="8">Stage 8</option>
              <option value="9">Stage 9</option>
              <option value="10">Stage 10</option>
              <option value="11">Stage 11</option>
              <option value="12">Stage 12</option>
            </select>
          </div>
          <div class="input-field">
            <label for="ringFilter">Ring focus</label>
            <select id="ringFilter">
              <option value="all">All rings</option>
              <option value="1">Ring 1</option>
              <option value="2">Ring 2</option>
              <option value="3">Ring 3</option>
              <option value="4">Ring 4</option>
              <option value="5">Ring 5</option>
              <option value="6">Ring 6</option>
              <option value="7">Ring 7</option>
              <option value="8">Ring 8</option>
            </select>
          </div>
        </div>
        <label class="toggle">
          <input type="checkbox" id="activeOnly" />
          <span>Show active aspects only</span>
        </label>
        <div class="filter-actions">
          <button id="btnResetFilters" class="btn tertiary small" type="button">Reset</button>
          <span id="filterSummary" class="vis-hint">All aspects visible.</span>
        </div>
      </div>

      <div class="panel scroll" aria-label="Aspect controls">
        <div id="aspectList" class="aspect-list" role="listbox" aria-multiselectable="false"></div>
      </div>

      <div class="panel" aria-label="Legend and codes">
        <div class="tags" style="margin-bottom:6px">
          <span class="tag">Brain: PFC, Limbic, Insula, Amygdala…</span>
          <span class="tag">NT: 5-HT, DA, NE, GABA, ACh, Oxytocin</span>
          <span class="tag">Modes: visual, auditory, interoceptive…</span>
        </div>
        <p class="vis-hint">Keyboard: Arrow keys pan focus · Enter opens details · T tutorial · R shuffle · E export · 0 clear</p>
      </div>
    </aside>
    <section class="codex-suite" aria-label="Codex authoring environment">
      <div class="panel codex-editor" aria-live="polite">
        <h2>Codex Editor</h2>
        <p class="vis-hint">Edit the codex descriptor, validate against the schema, and push updates directly to the live preview.</p>
        <div class="input-field">
          <label for="codexPrompt">Prompt helper</label>
          <div class="prompt-wrapper">
            <textarea id="codexPrompt" rows="3" placeholder="Describe the transformation, include target modality, scope, and success criteria."></textarea>
            <ul id="promptSuggestions" class="suggestions" role="listbox" aria-label="Prompt suggestions" hidden></ul>
          </div>
          <p class="vis-hint">Start typing to receive adaptive suggestions—select one to auto-complete the prompt.</p>
        </div>
        <div class="input-field">
          <label for="codexSource">Codex JSON</label>
          <textarea id="codexSource" rows="14" spellcheck="false" aria-describedby="codexStatus"></textarea>
        </div>
        <div class="codex-actions">
          <button id="codexFormat" class="btn secondary" type="button">Format JSON</button>
          <button id="codexSave" class="btn" type="button">Save &amp; Refresh Preview</button>
          <div id="codexStatus" class="codex-status" data-state="info" role="status">Awaiting edits. Format or save to validate.</div>
        </div>
        <form id="visitorNoteForm" class="visitor-feedback" aria-describedby="visitorStatus">
          <div>
            <h3>Visitor Note</h3>
            <p class="vis-hint">Share a quick insight to accompany Codex canvas adjustments.</p>
          </div>
          <label for="visitorMessage" class="visitor-label">Visitor message</label>
          <div class="visitor-message-field">
            <input id="visitorMessage" name="visitorMessage" type="text" maxlength="240" placeholder="Capture a reflection, request, or observation…" required />
            <button id="visitorSubmit" class="btn secondary" type="submit">Share note</button>
          </div>
          <p id="visitorStatus" class="visitor-status" role="status" aria-live="polite"></p>
        </form>
      </div>
      <div class="panel codex-preview">
        <h2>Live Preview</h2>
        <p class="vis-hint">The preview refreshes automatically after each successful save.</p>
        <iframe id="codexPreview" title="Codex live preview" sandbox="allow-same-origin"></iframe>
      </div>
      <div class="panel codex-docs">
        <h2>Implementation Notes</h2>
        <p class="vis-hint">Summary of the enhancements applied to the codex environment.</p>
        <ol id="codexChangelog">
          <li><strong>Preview workspace</strong> — Added a dedicated codex editor and adjacent live preview iframe with auto-refresh.</li>
          <li><strong>Schema guardrails</strong> — Implemented JSON schema validation with inline feedback for codex documents.</li>
          <li><strong>IntelliPrompt</strong> — Wired contextual prompt suggestions and auto-completion for faster authoring.</li>
        </ol>
      </div>
    </section>
    <div class="panel-overlay" id="panelOverlay" aria-hidden="true"></div>

    <footer>
      <div class="vis-hint">C = E × MC · Energy input → neural region → neurochemical output → system response</div>
      <div class="vis-hint">Open science: Export preserves all annotations for reproducibility</div>
      <div class="vis-hint">Adrian Lei Martinez-Conol, founder of the Only When Prompted Research Initiative 2018</div>
    </footer>
  </div>

  <!-- Info Modal (tooltip-like, accessible) -->
  <dialog id="infoModal" aria-label="Aspect details">
    <div class="modal-head">
      <strong id="mTitle">Aspect</strong>
      <button class="btn" value="cancel">Close</button>
    </div>
    <div class="modal-body">
      <div id="mDef" class="panel"></div>
      <div class="modal-grid">
        <div>
          <div><strong>Brain Region(s)</strong></div>
          <div id="mBrain" aria-live="polite"></div>
        </div>
        <div>
          <div><strong>Neurochemistry</strong></div>
          <div id="mNT"></div>
        </div>
        <div>
          <div><strong>Energy Pathway / Sensory</strong></div>
          <div id="mEnergy"></div>
        </div>
        <div>
          <div><strong>Developmental Stage · Ring</strong></div>
          <div id="mStage"></div>
        </div>
      </div>
      <div class="panel">
        <label for="mSlider"><strong>Activation</strong> <span id="mActVal" style="float:right">0</span></label>
        <input id="mSlider" type="range" min="0" max="100" value="0" />
      </div>
      <div class="panel">
        <strong>Matter/Energy Summary</strong>
        <div id="mSummary"></div>
      </div>
    </div>
  </dialog>

  <dialog id="sciModal" aria-label="Semantic Coherence Index explanation">
    <form method="dialog" class="modal-body">
      <header class="modal-head">
        <strong>Semantic Coherence Index</strong>
        <button class="btn" value="cancel">Close</button>
      </header>
      <p>The SCI summarises how harmoniously the 32 aspect activations align. It blends three signals:</p>
      <ol>
        <li><strong>Activation mean</strong> — higher overall activation raises the index.</li>
        <li><strong>Distribution balance</strong> — lower variance indicates the system is coherent.</li>
        <li><strong>Resonance coverage</strong> — similar stages, rings, and activation levels reinforce the network.</li>
      </ol>
      <p>The live value is scaled to 0–100 and updates instantly as you adjust sliders, shuffle activations, or change developmental emphasis.</p>
      <p id="sciFormula" class="vis-hint"></p>
    </form>
  </dialog>

  <dialog id="tutorialDialog" aria-label="Interactive tutorial">
    <form method="dialog" class="modal-body">
      <header class="modal-head">
        <strong>Self Clock Tutorial</strong>
        <button class="btn" value="cancel">Close</button>
      </header>
      <ol id="tutorialContent" class="tutorial-list"></ol>
    </form>
  </dialog>

  <dialog id="exportDialog" aria-label="Export options">
    <form method="dialog" class="modal-body">
      <header class="modal-head">
        <strong>Export Current Map</strong>
        <button class="btn" value="cancel">Close</button>
      </header>
      <p>Select a format to download the current developmental snapshot, including the SCI and resonance metrics.</p>
      <div class="export-grid">
        <button id="exportJson" class="btn" value="json">JSON (raw data)</button>
        <button id="exportCsv" class="btn secondary" value="csv">CSV (spreadsheet)</button>
        <button id="exportReport" class="btn secondary" value="html">Printable report</button>
      </div>
    </form>
  </dialog>

  <script>
    /* ============================================================
       DATA MODEL
       ------------------------------------------------------------
       • Three model lenses: Mind / Body / Soul
       • Each lens has 32 aspects with a 12-point developmental profile
    ============================================================ */

    const N_ASPECTS = 32;
    const TWO_PI = Math.PI * 2;
    const center = { x: 0, y: 0 };
    const DEV_STAGES = 12;
    const DEV_STAGE_LABELS = [
      'Infancy', 'Attachment', 'Exploration', 'Identity', 'Competence', 'Integration',
      'Visioning', 'Collaboration', 'Leadership', 'Stewardship', 'Legacy', 'Wisdom'
    ];

    const BIO_LIBRARY = {
      brain: {
        PFC: { name: 'Prefrontal Cortex', summary: 'Executive control, planning, and modulation of complex behaviours.' },
        Limbic: { name: 'Limbic Network', summary: 'Emotional appraisal, memory tagging, and motivation coupling.' },
        Insula: { name: 'Insular Cortex', summary: 'Interoceptive awareness and translation of body state to feeling tone.' },
        Amygdala: { name: 'Amygdala', summary: 'Rapid salience detection, threat appraisal, and emotional tagging.' },
        Hippocampus: { name: 'Hippocampus', summary: 'Contextual memory integration and spatial-temporal mapping.' },
        ACC: { name: 'Anterior Cingulate Cortex', summary: 'Conflict monitoring, attention regulation, and adaptive focus.' },
        'Basal Ganglia': { name: 'Basal Ganglia', summary: 'Sequencing of actions, habit formation, and energy gating.' },
        Cerebellum: { name: 'Cerebellum', summary: 'Sensorimotor prediction, timing, and embodied coordination.' }
      },
      nt: {
        '5-HT': { name: 'Serotonin (5-HT)', summary: 'Mood stabilisation, sensory integration, and behavioural flexibility.' },
        DA: { name: 'Dopamine (DA)', summary: 'Reward tracking, motivation, and precision of mental models.' },
        NE: { name: 'Norepinephrine (NE)', summary: 'Arousal, alerting, and prioritisation of salient cues.' },
        GABA: { name: 'GABA', summary: 'Primary inhibitory tone moderating excitability and balance.' },
        ACh: { name: 'Acetylcholine (ACh)', summary: 'Attention sharpening, neuroplasticity, and state transitions.' },
        Oxytocin: { name: 'Oxytocin', summary: 'Social bonding, trust calibration, and affiliative safety.' },
        Endorphins: { name: 'Endorphins', summary: 'Analgesia, euphoria, and stress recovery buffering.' }
      },
      modes: {
        visual: { name: 'Visual', summary: 'Pattern and imagery channels guiding anticipatory modelling.' },
        auditory: { name: 'Auditory', summary: 'Temporal sequencing and linguistic-phonetic attunement.' },
        interoceptive: { name: 'Interoceptive', summary: 'Sensing internal physiology for regulation and self-awareness.' },
        proprioceptive: { name: 'Proprioceptive', summary: 'Muscle and joint awareness for posture and embodied context.' },
        vestibular: { name: 'Vestibular', summary: 'Balance, orientation, and gravitational reference frames.' },
        somatic: { name: 'Somatic', summary: 'Touch, pressure, and visceral grounding of experience.' }
      }
    };

    const TUTORIAL_STEPS = [
      { title: 'Navigate the map', detail: 'Use the arrow keys or tap nodes to cycle the 32 aspects. Focus is highlighted on the clock and in the list.' },
      { title: 'Inspect activations', detail: 'Press Enter or the Details buttons to open the aspect modal. Adjust activation sliders to see immediate SCI feedback.' },
      { title: 'Semantic Coherence Index', detail: 'Watch the SCI metric for balance (variance), power (mean activation), and resonance coverage (stage/ring alignment).' },
      { title: 'Developmental emphasis', detail: 'The stage slider loads the canonical devProfile while Stage Emphasis multipliers let you weight phases that matter now.' },
      { title: 'Comparative mode', detail: 'Select any two stages to surface leading increases/decreases across the aspect network.' },
      { title: 'Resonance links', detail: 'Green–blue links join aspects that co-activate or share structural placement. Denser links = higher coherence.' },
      { title: 'Exports for research', detail: 'Press E or Export to choose JSON, CSV, or a printable briefing with SCI formula details.' }
    ];

    const palette = {
      ring1: '#1a214a',
      ring2: '#161c3f',
      stage: '#24306f',
      label: '#cbd5f1',
      focus: '#fde68a',
      nodeBorder: '#0b0f2a',
      resonanceA: '#34d399',
      resonanceB: '#7dd3fc'
    };

    function refreshPalette() {
      const styles = getComputedStyle(document.body);
      const fetch = (name, fallback) => {
        const val = styles.getPropertyValue(name);
        return val ? val.trim() : fallback;
      };
      palette.ring1 = fetch('--ring-line-1', palette.ring1);
      palette.ring2 = fetch('--ring-line-2', palette.ring2);
      palette.stage = fetch('--stage-line', palette.stage);
      palette.label = fetch('--node-label', palette.label);
      palette.focus = fetch('--focus', palette.focus);
      palette.nodeBorder = fetch('--glass-stroke', palette.nodeBorder);
      palette.resonanceA = fetch('--good', palette.resonanceA);
      palette.resonanceB = fetch('--accent', palette.resonanceB);
    }

    function detectInitialTheme() {
      try {
        const stored = localStorage.getItem('selfClockTheme');
        if (stored === 'light' || stored === 'dark') return stored;
      } catch (_) { /* ignore */ }
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark';
      }
      return 'light';
    }

    function updateThemeButton() {
      if (!themeBtn) return;
      const next = state.theme === 'dark' ? 'light' : 'dark';
      themeBtn.textContent = state.theme === 'dark' ? '☀️ Light' : '🌙 Dark';
      themeBtn.setAttribute('title', `Switch to ${next} mode`);
      themeBtn.setAttribute('aria-pressed', String(state.theme === 'light'));
    }

    function applyTheme(theme) {
      state.theme = theme;
      document.body.setAttribute('data-theme', theme);
      try { localStorage.setItem('selfClockTheme', theme); } catch (_) { /* ignore */ }
      refreshPalette();
      updateThemeButton();
      draw();
    }

    function updatePanelToggleLabel() {
      if (!panelToggle) return;
      const open = state.panelOpen;
      const label = open ? 'Hide insights panel' : 'Show insights panel';
      panelToggle.textContent = open ? 'Hide Panel' : 'Show Panel';
      panelToggle.setAttribute('aria-expanded', String(open));
      panelToggle.setAttribute('aria-label', label);
    }

    function focusWithoutScroll(el) {
      if (!el || typeof el.focus !== 'function') return;
      try {
        el.focus({ preventScroll: true });
      } catch (_) {
        el.focus();
      }
    }

    function setInert(el, inert) {
      if (!el) return;
      if ('inert' in el) {
        el.inert = inert;
      }
      if (inert) {
        el.setAttribute('inert', '');
      } else {
        el.removeAttribute('inert');
      }
    }

    function setPanelState(open, options = {}) {
      const { focusToggle = true } = options;
      state.panelOpen = open;
      document.body.setAttribute('data-panel', open ? 'open' : 'closed');
      const isMobile = state.layout === 'mobile';
      if (panelOverlay) {
        const overlayVisible = open && isMobile;
        panelOverlay.hidden = !overlayVisible;
        panelOverlay.setAttribute('aria-hidden', overlayVisible ? 'false' : 'true');
      }
      updatePanelToggleLabel();
      if (!insightPanel) return;

      if (open) {
        insightPanel.removeAttribute('hidden');
        insightPanel.setAttribute('aria-hidden', 'false');
        setInert(insightPanel, false);
        if (isMobile) {
          insightPanel.setAttribute('tabindex', '-1');
          focusWithoutScroll(insightPanel);
        } else {
          insightPanel.removeAttribute('tabindex');
        }
        return;
      }

      // Closing state handling
      if (isMobile) {
        insightPanel.setAttribute('aria-hidden', 'true');
        insightPanel.setAttribute('hidden', '');
        setInert(insightPanel, true);
        insightPanel.removeAttribute('tabindex');
        if (focusToggle && panelToggle) {
          focusWithoutScroll(panelToggle);
        }
      } else {
        insightPanel.removeAttribute('hidden');
        insightPanel.setAttribute('aria-hidden', 'false');
        setInert(insightPanel, false);
        insightPanel.removeAttribute('tabindex');
      }
    }

    function applyLayoutMode(isMobile) {
      state.layout = isMobile ? 'mobile' : 'desktop';
      document.body.setAttribute('data-layout', state.layout);
      if (state.layout === 'mobile') {
        setPanelState(false, { focusToggle: false });
      } else {
        setPanelState(true, { focusToggle: false });
        if (insightPanel) {
          insightPanel.removeAttribute('tabindex');
          insightPanel.removeAttribute('hidden');
          insightPanel.setAttribute('aria-hidden', 'false');
          setInert(insightPanel, false);
        }
      }
    }

    // Placeholders; replace with canonical mappings as needed
    const BRAIN = ["PFC", "Limbic", "Insula", "Amygdala", "Hippocampus", "ACC", "Basal Ganglia", "Cerebellum"];
    const NT = ["5-HT", "DA", "NE", "GABA", "ACh", "Oxytocin", "Endorphins"];
    const MODES = ["visual", "auditory", "somatic", "interoceptive", "proprioceptive", "vestibular"];

    // Developmental profile generator (smooth rise → peak → taper)
    function makeDevProfile(i, stage, ring) {
      const len = DEV_STAGES;
      const arr = [];
      const phase = (stage-1) / 12;      // shift by nominal stage
      const amp = 0.6 + (ring/8)*0.3;    // outer rings slightly higher
      const noise = (seed)=> (Math.sin((i+1)*(seed+1.73))*0.04);
      for (let s=0; s<len; s++) {
        const t = s/(len-1);             // 0..1 lifespan
        const bell = Math.sin(Math.PI * (t*0.85 + phase*0.12));
        const base = Math.max(0, bell) * amp + 0.15*(1 - Math.pow(1-t, 3));
        const val = Math.max(0, Math.min(1, base + noise(s)));
        arr.push(Math.round(val*100));
      }
      return arr;
    }

    // Build a complete 32-aspect set for a given lens (mind/body/soul)
    function makeAspectSet(model) {
      return Array.from({ length: N_ASPECTS }, (_, i) => {
        const hue = Math.round((i * (360 / N_ASPECTS)) % 360);
        const stage = 1 + (i % 12);
        const ring  = 1 + (i % 8);
        const devProfile = makeDevProfile(i, stage, ring);
        const base = {
          id: i+1,
          name: `${model[0].toUpperCase()+model.slice(1)} Aspect ${i+1}`,
          stage, ring, hue,
          activation: devProfile[0],
          devProfile,
        };
        if (model === 'mind') {
          return Object.assign(base, {
            definition: "Cognitive/semantic placeholder.",
            corePsychologicalRole: "Role placeholder",
            nsilSemanticSignature: "nsil:placeholder",
            semanticGravity: "attractor",
            quantumMode: ["particle","wave","field"][i%3],
            particleWaveFieldFunction: "propagation placeholder",
            brainRegion: "—",
            neurotransmitter: "—",
            energyMode: "—",
            matterOutput: "—",
          });
        }
        if (model === 'body') {
          const brainKey = BRAIN[i % BRAIN.length];
          const ntKey = NT[i % NT.length];
          const modeKey = MODES[i % MODES.length];
          return Object.assign(base, {
            definition: "Neuro/physiology placeholder.",
            brainRegionKey: brainKey,
            brainRegion: BIO_LIBRARY.brain[brainKey]?.name || brainKey,
            neurotransmitterKey: ntKey,
            neurotransmitter: BIO_LIBRARY.nt[ntKey]?.name || ntKey,
            energyModeKey: modeKey,
            energyMode: BIO_LIBRARY.modes[modeKey]?.name || modeKey,
            matterOutput: "Physiological function",
          });
        }
        // soul
        return Object.assign(base, {
          definition: "Archetypal/transpersonal placeholder.",
          archetypalSymbol: "Symbol",
          spiritualRole: "Role",
          nsilPrincipleSignature: "nsil:principle",
          brainRegion: "—",
          neurotransmitter: "—",
          energyMode: "—",
          matterOutput: "—",
        });
      });
    }

    // Three parallel datasets (placeholders until you provide canonical labels)
    const mindAspects = makeAspectSet('mind');
    const bodyAspects = makeAspectSet('body');
    const soulAspects = makeAspectSet('soul');

    // Active lens state
    let mode = 'mind';
    let aspects = mindAspects;

    /* ============================================================
       STATE + METRICS
    ============================================================ */
    const state = {
      resonanceThreshold: 18, // activation similarity to link nodes
      tutorial: false,
      tutorialIndex: 0,
      focusId: 1,
      devStage: 0,
      stageWeights: Array.from({ length: DEV_STAGES }, () => 1),
      filterText: '',
      sort: 'stage',
      stageFilter: 'all',
      ringFilter: 'all',
      activeOnly: false,
      theme: 'dark',
      layout: 'desktop',
      panelOpen: true,
      visible: [...aspects],
    };

    function computeResonanceStats() {
      let total = 0;
      let supportive = 0;
      let stageAligned = 0;
      let ringAligned = 0;
      let activationAligned = 0;
      for (let i = 0; i < aspects.length; i++) {
        for (let j = i + 1; j < aspects.length; j++) {
          total++;
          const ai = aspects[i];
          const aj = aspects[j];
          const diff = Math.abs(ai.activation - aj.activation);
          const sim = diff <= state.resonanceThreshold;
          const sameStage = ai.stage === aj.stage;
          const sameRing = ai.ring === aj.ring;
          if (sim || sameStage || sameRing) {
            supportive++;
            if (sim) activationAligned++;
            if (sameStage) stageAligned++;
            if (sameRing) ringAligned++;
          }
        }
      }
      const ratio = total ? supportive / total : 0;
      return { total, supportive, ratio, stageAligned, ringAligned, activationAligned };
    }

    function computeSCI() {
      const vals = aspects.map(a => a.activation);
      const mean = vals.reduce((a,b)=>a+b,0) / vals.length;
      const variance = vals.reduce((acc, v)=> acc + Math.pow(v-mean, 2), 0) / vals.length;
      const std = Math.sqrt(variance);
      const activationScore = mean / 100; // 0..1
      const balance = 1 - Math.min(1, std / 35); // 0..1
      const resonance = computeResonanceStats();
      const resonanceScore = resonance.ratio;
      const alignmentScore = resonance.total ? ((resonance.stageAligned + resonance.ringAligned) / (2 * resonance.total)) : 0;
      const weighted = (activationScore * 0.35) + (balance * 0.35) + (resonanceScore * 0.2) + (alignmentScore * 0.1);
      const sci = Math.max(0, Math.min(100, weighted * 100));
      return { mean, std, sci, activationScore, balance, resonance, resonanceScore, alignmentScore };
    }

    // Energy–Matter overview (simple but informative proxy)
    function computeEnergyMatter() {
      const total = aspects.reduce((s,a)=> s + a.activation, 0);
      const byNT = new Map();
      for (const a of aspects) {
        const k = a.neurotransmitter || '—';
        byNT.set(k, (byNT.get(k)||0) + a.activation);
      }
      const metabolic = total / (N_ASPECTS * 100);
      return { total, byNT, metabolic };
    }

    /* ============================================================
       DOM HELPERS
    ============================================================ */
    const el = sel => document.querySelector(sel);
    const listEl = el('#aspectList');
    const sciEl  = el('#sciVal');
    const emEl   = el('#emVal');
    const activeEl = el('#activeVal');
    const peakEl = el('#peakVal');
    const sciStatusEl = el('#sciStatus');
    const sciFormulaEl = el('#sciFormula');
    const sciInfoBtn = el('#btnSciInfo');
    const sciModal = el('#sciModal');
    const filterSummaryEl = el('#filterSummary');
    const devSlider = el('#devStageSlider');
    const devVal = el('#devStageVal');
    const stageWeightSelect = el('#stageWeightSelect');
    const stageWeightSlider = el('#stageWeightSlider');
    const stageWeightValue = el('#stageWeightValue');
    const resetWeightsBtn = el('#btnResetWeights');
    const compareStageA = el('#compareStageA');
    const compareStageB = el('#compareStageB');
    const comparisonSummaryEl = el('#comparisonSummary');
    const searchInput = el('#searchInput');
    const sortSelect = el('#sortSelect');
    const stageFilterSelect = el('#stageFilter');
    const ringFilterSelect = el('#ringFilter');
    const activeOnlyToggle = el('#activeOnly');
    const resetFiltersBtn = el('#btnResetFilters');
    const themeBtn = el('#btnTheme');
    const panelToggle = el('#panelToggle');
    const panelClose = el('#panelClose');
    const panelOverlay = el('#panelOverlay');
    const insightPanel = el('#insightPanel');
    const tutorialDialog = el('#tutorialDialog');
    const tutorialListEl = el('#tutorialContent');
    const exportDialog = el('#exportDialog');
    const exportJsonBtn = el('#exportJson');
    const exportCsvBtn = el('#exportCsv');
    const exportReportBtn = el('#exportReport');
    const tutorialBtn = el('#btnTutorial');
    const exportBtn = el('#btnExport');

    function describeBrain(key, fallback) {
      if (!key) return fallback || '—';
      const def = BIO_LIBRARY.brain[key];
      if (!def) return fallback || key;
      return `<strong>${def.name}</strong><br><span class="vis-hint">${def.summary}</span>`;
    }

    function describeNeurochemical(key, fallback) {
      if (!key) return fallback || '—';
      const def = BIO_LIBRARY.nt[key];
      if (!def) return fallback || key;
      return `<strong>${def.name}</strong><br><span class="vis-hint">${def.summary}</span>`;
    }

    function describeMode(key, fallback) {
      if (!key) return fallback || '—';
      const def = BIO_LIBRARY.modes[key];
      if (!def) return fallback || key;
      return `<strong>${def.name}</strong><br><span class="vis-hint">${def.summary}</span>`;
    }

    function buildTutorialList() {
      if (!tutorialListEl) return;
      tutorialListEl.innerHTML = TUTORIAL_STEPS.map(step => `<li><strong>${step.title}</strong> — ${step.detail}</li>`).join('');
    }

    function updateComparisonSummary() {
      if (!comparisonSummaryEl || !compareStageA || !compareStageB) return;
      const aIdx = Number(compareStageA.value);
      const bIdx = Number(compareStageB.value);
      if (!Number.isFinite(aIdx) || !Number.isFinite(bIdx)) {
        comparisonSummaryEl.textContent = 'Select two stages to compare their activation patterns.';
        return;
      }
      if (aIdx === bIdx) {
        comparisonSummaryEl.textContent = 'Choose two distinct developmental points for comparison.';
        return;
      }
      const dataset = mode === 'mind' ? mindAspects : mode === 'body' ? bodyAspects : soulAspects;
      const mean = (vals) => vals.reduce((sum, val) => sum + val, 0) / vals.length;
      const valuesA = dataset.map(a => a.devProfile?.[aIdx] ?? 0);
      const valuesB = dataset.map(a => a.devProfile?.[bIdx] ?? 0);
      const meanA = mean(valuesA);
      const meanB = mean(valuesB);
      const diffs = dataset.map((a, idx) => ({ name: a.name, delta: valuesB[idx] - valuesA[idx] }));
      const topUp = diffs.filter(d => d.delta > 0).sort((a,b)=>b.delta-a.delta).slice(0,3);
      const topDown = diffs.filter(d => d.delta < 0).sort((a,b)=>a.delta-b.delta).slice(0,3);
      const fmt = (arr) => arr.length ? arr.map(d => `${escapeHtml(d.name)} (${d.delta > 0 ? '+' : ''}${d.delta.toFixed(0)})`).join(', ') : '—';
      const delta = meanB - meanA;
      comparisonSummaryEl.innerHTML = `
        <p><strong>${stageLabel(bIdx)}</strong> mean ${(delta>=0?'+':'')}${delta.toFixed(1)} relative to <strong>${stageLabel(aIdx)}</strong>.</p>
        <p><strong>Leading increases:</strong> ${fmt(topUp)}</p>
        <p><strong>Leading decreases:</strong> ${fmt(topDown)}</p>`;
    }

    function stageLabel(stageIndex) {
      const name = DEV_STAGE_LABELS[stageIndex] || '';
      return `Stage ${stageIndex + 1}${name ? ` · ${name}` : ''}`;
    }

    function applyDevStage(stage){
      state.devStage = stage;
      if (devVal) devVal.textContent = stageLabel(stage);
      const currentWeight = state.stageWeights[stage] ?? 1;
      if (stageWeightSelect) stageWeightSelect.value = String(stage);
      if (stageWeightSlider) stageWeightSlider.value = String(currentWeight);
      if (stageWeightValue) stageWeightValue.textContent = `${Number(currentWeight).toFixed(2)}×`;
      aspects.forEach(a => {
        if (a.devProfile?.length === DEV_STAGES) {
          const base = a.devProfile[stage] ?? 0;
          const weight = state.stageWeights[(a.stage - 1) % state.stageWeights.length] ?? 1;
          const weighted = Math.max(0, Math.min(100, Math.round(base * weight)));
          a.baseActivation = base;
          a.activation = weighted;
        }
      });
      updateMetrics();
      buildList();
      draw();
      updateComparisonSummary();
    }

    function populateStageSelectors() {
      const options = DEV_STAGE_LABELS.map((label, idx) => `<option value="${idx}">${stageLabel(idx)}</option>`).join('');
      if (stageWeightSelect) stageWeightSelect.innerHTML = options;
      if (compareStageA) compareStageA.innerHTML = options;
      if (compareStageB) compareStageB.innerHTML = options;
      if (stageWeightSelect) stageWeightSelect.value = String(state.devStage);
      if (compareStageA) compareStageA.value = '0';
      if (compareStageB) compareStageB.value = '6';
      if (stageWeightSlider) stageWeightSlider.value = String(state.stageWeights[state.devStage] ?? 1);
      if (stageWeightValue) stageWeightValue.textContent = `${Number(stageWeightSlider?.value || 1).toFixed(2)}×`;
    }

    populateStageSelectors();
    buildTutorialList();
    updateComparisonSummary();

    if (devSlider) devSlider.addEventListener('input', (e)=> applyDevStage(Number(e.target.value)));
    if (stageWeightSelect) stageWeightSelect.addEventListener('change', (e)=> {
      const idx = Number(e.target.value);
      const weight = state.stageWeights[idx] ?? 1;
      if (stageWeightSlider) stageWeightSlider.value = String(weight);
      if (stageWeightValue) stageWeightValue.textContent = `${Number(weight).toFixed(2)}×`;
    });
    if (stageWeightSlider) stageWeightSlider.addEventListener('input', (e)=> {
      const idx = Number(stageWeightSelect?.value ?? state.devStage);
      const val = Number(e.target.value);
      if (!Number.isFinite(idx)) return;
      state.stageWeights[idx] = val;
      if (stageWeightValue) stageWeightValue.textContent = `${val.toFixed(2)}×`;
      applyDevStage(state.devStage);
    });
    if (resetWeightsBtn) resetWeightsBtn.addEventListener('click', ()=> {
      state.stageWeights = Array.from({ length: DEV_STAGES }, () => 1);
      if (stageWeightSelect) stageWeightSelect.value = String(state.devStage);
      if (stageWeightSlider) stageWeightSlider.value = '1';
      if (stageWeightValue) stageWeightValue.textContent = '1.00×';
      applyDevStage(state.devStage);
    });
    if (compareStageA) compareStageA.addEventListener('change', updateComparisonSummary);
    if (compareStageB) compareStageB.addEventListener('change', updateComparisonSummary);
    if (searchInput) searchInput.addEventListener('input', (e)=> { state.filterText = e.target.value || ''; buildList(); });
    if (sortSelect) sortSelect.addEventListener('change', (e)=> { state.sort = e.target.value; buildList(); });
    if (stageFilterSelect) stageFilterSelect.addEventListener('change', (e)=> { state.stageFilter = e.target.value; buildList(); });
    if (ringFilterSelect) ringFilterSelect.addEventListener('change', (e)=> { state.ringFilter = e.target.value; buildList(); });
    if (activeOnlyToggle) activeOnlyToggle.addEventListener('change', (e)=> { state.activeOnly = e.target.checked; buildList(); });
    if (resetFiltersBtn) resetFiltersBtn.addEventListener('click', ()=> {
      state.filterText = '';
      state.sort = 'stage';
      state.stageFilter = 'all';
      state.ringFilter = 'all';
      state.activeOnly = false;
      if (searchInput) searchInput.value = '';
      if (sortSelect) sortSelect.value = 'stage';
      if (stageFilterSelect) stageFilterSelect.value = 'all';
      if (ringFilterSelect) ringFilterSelect.value = 'all';
      if (activeOnlyToggle) activeOnlyToggle.checked = false;
      buildList();
    });
    if (themeBtn) themeBtn.addEventListener('click', ()=> applyTheme(state.theme === 'dark' ? 'light' : 'dark'));
    if (panelToggle) panelToggle.addEventListener('click', ()=> setPanelState(!state.panelOpen));
    if (panelClose) panelClose.addEventListener('click', ()=> setPanelState(false));
    if (panelOverlay) panelOverlay.addEventListener('click', ()=> setPanelState(false));

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && state.layout === 'mobile' && state.panelOpen) {
        setPanelState(false);
      }
    });

    function tagHTML(a){
      if (mode==='mind') {
        return `<span class="tag">${a.quantumMode}</span><span class="tag">NSIL</span><span class="tag">${a.semanticGravity}</span>`;
      } else if (mode==='body') {
        return `<span class="tag">${a.brainRegion}</span><span class="tag">${String(a.neurotransmitter||'—').split(' ')[0]}</span><span class="tag">${a.energyMode}</span>`;
      }
      return `<span class="tag">${a.archetypalSymbol}</span><span class="tag">${a.spiritualRole}</span><span class="tag">NSIL</span>`;
    }

    function hsl(h, s=70, l=52) { return `hsl(${h} ${s}% ${l}%)`; }
    function hslAlpha(h, a=.25, s=70, l=50) { return `hsl(${h} ${s}% ${l}% / ${a})`; }

    function formatSciFormula(metrics) {
      const act = (metrics.activationScore * 100).toFixed(1);
      const bal = (metrics.balance * 100).toFixed(1);
      const res = (metrics.resonanceScore * 100).toFixed(1);
      const align = (metrics.alignmentScore * 100).toFixed(1);
      return `SCI = (0.35×${act}% + 0.35×${bal}% + 0.20×${res}% + 0.10×${align}%) → ${metrics.sci.toFixed(1)}`;
    }

    function updateMetrics() {
      const metrics = computeSCI();
      const { mean, std, sci, resonanceScore, resonance } = metrics;
      if (sciEl) {
        sciEl.innerHTML = `${sci.toFixed(1)}<small>μ=${mean.toFixed(1)}, σ=${std.toFixed(1)}, resonance ${(resonanceScore*100).toFixed(0)}%</small>`;
      }
      if (sciStatusEl) {
        let status = 'Awaiting activation data.';
        if (sci >= 75) {
          status = 'High coherence — activations are harmonised and richly resonant.';
        } else if (sci >= 55) {
          status = 'Moderate coherence — adjust stage emphasis or balance activations.';
        } else {
          status = 'Fragmented network — reduce variance or strengthen shared links.';
        }
        const coverage = resonance.total ? ` Resonance coverage ${(resonanceScore*100).toFixed(0)}% across ${resonance.supportive}/${resonance.total} links.` : '';
        sciStatusEl.textContent = status + coverage;
      }
      if (sciFormulaEl) {
        sciFormulaEl.textContent = formatSciFormula(metrics);
      }
      const { total, byNT, metabolic } = computeEnergyMatter();
      const top = [...byNT.entries()].sort((a,b)=>b[1]-a[1]).slice(0,2).map(([k,v])=> `${String(k).split(' ')[0]} ${Math.round(v)}` ).join(', ');
      if (emEl) emEl.textContent = `ΣE=${Math.round(total)} · NT↑ ${top || '—'} · Metabolic ${(metabolic*100).toFixed(0)}%`;
      const activeCount = aspects.filter(a => a.activation > 0).length;
      if (activeEl) activeEl.textContent = `${activeCount}/${N_ASPECTS}`;
      if (peakEl) {
        const peak = aspects.reduce((best, cand) => (cand.activation > (best?.activation ?? -1) ? cand : best), null);
        peakEl.innerHTML = peak ? `${peak.activation}<small>${peak.name}</small>` : '—';
      }
    }

    function createAspectRow(a) {
      const item = document.createElement('div');
      item.className = 'aspect-item';
      item.setAttribute('role', 'option');
      item.tabIndex = 0;
      item.dataset.id = a.id;
      item.setAttribute('aria-selected', a.id === state.focusId ? 'true' : 'false');

      const r1 = document.createElement('div');
      r1.className = 'row';
      r1.innerHTML = `<div class="name"><span class="dot" style="background:${hsl(a.hue)}"></span>${a.name}</div>
                      <span class="badge">Stage ${a.stage} · Ring ${a.ring}</span>`;

      const bar = document.createElement('div');
      bar.className = 'activation-bar';
      const barFill = document.createElement('span');
      barFill.style.width = `${a.activation}%`;
      barFill.style.background = `linear-gradient(90deg, ${hsl(a.hue, 70, 55)}, ${hslAlpha(a.hue, 0.45, 70, 55)})`;
      bar.appendChild(barFill);

      const r2 = document.createElement('div');
      r2.className = 'row';
      const label = document.createElement('label');
      label.textContent = `Activation: ${a.activation}`;
      label.style.flex = '1';
      label.htmlFor = `rng-${a.id}`;

      const range = document.createElement('input');
      range.type = 'range';
      range.min = 0;
      range.max = 100;
      range.value = a.activation;
      range.id = `rng-${a.id}`;
      range.style.flex = '1';
      range.setAttribute('aria-label', `${a.name} activation`);
      range.addEventListener('input', (e) => {
        a.activation = Number(e.target.value);
        label.textContent = `Activation: ${a.activation}`;
        barFill.style.width = `${a.activation}%`;
        draw();
        updateMetrics();
      });
      range.addEventListener('change', () => { state.focusId = a.id; buildList(); });

      const detailsBtn = document.createElement('button');
      detailsBtn.className = 'btn tertiary small';
      detailsBtn.type = 'button';
      detailsBtn.textContent = 'Details';
      detailsBtn.addEventListener('click', () => openModal(a));

      r2.append(label, range, detailsBtn);

      const r3 = document.createElement('div');
      r3.className = 'tags';
      r3.innerHTML = `${tagHTML(a)}`;

      item.append(r1, bar, r2, r3);

      item.addEventListener('click', () => { state.focusId = a.id; refreshListSelection(); draw(); });
      item.addEventListener('focus', () => { state.focusId = a.id; refreshListSelection(); draw(); });
      item.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); openModal(a); }
      });

      return item;
    }

    function refreshListSelection() {
      if (!listEl) return;
      listEl.querySelectorAll('[data-id]').forEach(ch => ch.setAttribute('aria-selected', ch.dataset.id == state.focusId ? 'true':'false'));
    }

    function matchesFilter(a, needle) {
      if (!needle) return true;
      const hay = [
        a.name,
        a.definition,
        a.brainRegion,
        a.neurotransmitter,
        a.energyMode,
        a.semanticGravity,
        a.archetypalSymbol,
        a.spiritualRole,
        a.matterOutput
      ].filter(Boolean).join(' ').toLowerCase();
      return hay.includes(needle);
    }

    function getVisibleAspects() {
      const needle = state.filterText.trim().toLowerCase();
      const stageFilter = state.stageFilter;
      const ringFilter = state.ringFilter;
      const filtered = aspects.filter(a => {
        if (stageFilter !== 'all' && String(a.stage) !== stageFilter) return false;
        if (ringFilter !== 'all' && String(a.ring) !== ringFilter) return false;
        if (state.activeOnly && a.activation <= 0) return false;
        return matchesFilter(a, needle);
      });
      const sorted = [...filtered];
      sorted.sort((a, b) => {
        switch (state.sort) {
          case 'activationDesc':
            return (b.activation - a.activation) || a.name.localeCompare(b.name);
          case 'activationAsc':
            return (a.activation - b.activation) || a.name.localeCompare(b.name);
          case 'name':
            return a.name.localeCompare(b.name);
          default:
            return (a.stage - b.stage) || (a.ring - b.ring) || (a.id - b.id);
        }
      });
      return sorted;
    }

    function updateFilterSummary(count) {
      if (!filterSummaryEl) return;
      if (!count) {
        filterSummaryEl.textContent = 'No aspects match the current filters.';
        return;
      }
      const parts = [`${count} of ${aspects.length} aspects shown`];
      if (state.filterText.trim()) parts.push(`“${state.filterText.trim()}”`);
      if (state.stageFilter !== 'all') parts.push(`Stage ${state.stageFilter}`);
      if (state.ringFilter !== 'all') parts.push(`Ring ${state.ringFilter}`);
      if (state.activeOnly) parts.push('Active > 0');
      filterSummaryEl.textContent = parts.join(' · ');
    }

    function buildList() {
      if (!listEl) return;
      const view = getVisibleAspects();
      state.visible = view;
      listEl.innerHTML = '';
      if (!view.length) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No aspects match the current filters.';
        listEl.appendChild(empty);
        updateFilterSummary(0);
        return;
      }
      if (!view.some(a => a.id === state.focusId)) {
        state.focusId = view[0].id;
      }
      view.forEach(a => listEl.appendChild(createAspectRow(a)));
      refreshListSelection();
      updateFilterSummary(view.length);
    }

    /* ============================================================
       CODEX ENVIRONMENT (editor + live preview)
    ============================================================ */
    const codexPromptEl = el('#codexPrompt');
    const codexSourceEl = el('#codexSource');
    const codexStatusEl = el('#codexStatus');
    const codexPreviewEl = el('#codexPreview');
    const codexFormatBtn = el('#codexFormat');
    const codexSaveBtn = el('#codexSave');
    const codexSuggestionsEl = el('#promptSuggestions');
    const visitorFormEl = el('#visitorNoteForm');
    const visitorMessageEl = el('#visitorMessage');
    const visitorStatusEl = el('#visitorStatus');
    const visitorSubmitEl = el('#visitorSubmit');

    function updateVisitorStatus(message, state = 'info') {
      if (!visitorStatusEl) return;
      visitorStatusEl.textContent = message;
      if (state === 'info' || !state) {
        visitorStatusEl.removeAttribute('data-state');
      } else {
        visitorStatusEl.setAttribute('data-state', state);
      }
    }

    updateVisitorStatus('');

    const promptTemplates = [
      'Map resonance between the selected aspect and a complementary body modality; return focus, practice, and reflection cues.',
      'Generate an actionable daily ritual that balances energy inflow with matter-based outputs for the highlighted stage.',
      'Outline a triadic narrative (mind, body, soul) describing how activation shifts cascade across systems.',
      'Design a facilitation prompt that invites imaginal sensing plus somatic grounding for this developmental ring.',
      'Summarise likely neurotransmitter shifts and recommend supportive interventions to stabilise the arc.',
      'Craft a research vignette with hypotheses, observable markers, and follow-up probes for this aspect.'
    ];

    const defaultCodexDocument = {
      id: 'codex-mind-resonance',
      title: 'Mind Aspect Resonance Blueprint',
      prompt: 'Map the current mind aspect activation to actionable practices. Provide a concise summary, the activation score, and at least two synergies to explore. Conclude with a reflection question.',
      schema: {
        type: 'object',
        description: 'Structured response used to drive the codex preview workspace.',
        properties: {
          summary: { type: 'string', description: 'Key insight about the aspect\'s current expression.' },
          activation: { type: 'number', description: 'Activation level between 0 and 100.', minimum: 0, maximum: 100 },
          synergies: {
            type: 'array',
            description: 'Related mind/body/soul anchors to investigate next.',
            items: { type: 'string' }
          }
        },
        required: ['summary', 'activation']
      },
      fields: [
        { id: 'summary', label: 'Summary', type: 'textarea', placeholder: 'Highlight resonance themes and leverage points.' },
        { id: 'activation', label: 'Activation', type: 'number', min: 0, max: 100, description: 'Numeric activation index (0–100).' },
        { id: 'synergies', label: 'Synergies', type: 'list', description: 'List 2–3 related patterns or practices.' }
      ]
    };

    const cloneCodex = (value) => (typeof structuredClone === 'function'
      ? structuredClone(value)
      : JSON.parse(JSON.stringify(value)));

    let codexModel = cloneCodex(defaultCodexDocument);
    let promptDirty = false;

    function updateCodexStatus(message, state = 'info') {
      if (!codexStatusEl) return;
      codexStatusEl.textContent = message;
      if (state === 'info') {
        codexStatusEl.removeAttribute('data-state');
      } else {
        codexStatusEl.setAttribute('data-state', state);
      }
    }

    function loadCodexModel(model, options = {}) {
      const { keepPrompt = false } = options;
      codexModel = cloneCodex(model);
      if (keepPrompt && codexPromptEl) {
        codexModel.prompt = codexPromptEl.value;
      }
      if (codexPromptEl && !keepPrompt) {
        promptDirty = false;
        codexPromptEl.value = codexModel.prompt || '';
      }
      if (codexSourceEl) {
        codexSourceEl.value = JSON.stringify(codexModel, null, 2);
      }
    }

    const escapeHTML = (value) => String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    function buildCodexPreviewDocument(data) {
      const required = new Set(Array.isArray(data?.schema?.required) ? data.schema.required : []);
      const properties = data?.schema?.properties && typeof data.schema.properties === 'object'
        ? Object.entries(data.schema.properties)
        : [];
      const fields = Array.isArray(data?.fields) ? data.fields : [];
      const propertyRows = properties.map(([key, cfg]) => {
        const type = escapeHTML(cfg?.type || 'any');
        const desc = escapeHTML(cfg?.description || '');
        const limits = [];
        if (typeof cfg?.minimum === 'number') limits.push(`min ${cfg.minimum}`);
        if (typeof cfg?.maximum === 'number') limits.push(`max ${cfg.maximum}`);
        if (cfg?.type === 'array' && cfg?.items?.type) {
          limits.push(`items: ${escapeHTML(cfg.items.type)}`);
        }
        const limitStr = limits.length ? `<span class="limits">${limits.join(' · ')}</span>` : '';
        const requiredBadge = required.has(key)
          ? '<span class="req">Required</span>'
          : '<span class="req optional">Optional</span>';
        return `<tr><th scope="row">${escapeHTML(key)}</th><td><div class="row-head">${requiredBadge}<span class="type">${type}</span></div><p>${desc || '—'}</p>${limitStr}</td></tr>`;
      }).join('');
      const fieldCards = fields.map((field) => {
        const hints = [];
        if (field?.type) hints.push(escapeHTML(field.type));
        if (typeof field?.min === 'number' || typeof field?.max === 'number') {
          const min = typeof field.min === 'number' ? field.min : '—';
          const max = typeof field.max === 'number' ? field.max : '—';
          hints.push(`range ${min}–${max}`);
        }
        return `<article><h3>${escapeHTML(field?.label || field?.id || 'Field')}</h3><p>${escapeHTML(field?.description || field?.placeholder || '') || '—'}</p><footer>${hints.join(' · ') || 'input'}</footer></article>`;
      }).join('');
      return `<!doctype html><html lang="en"><head><meta charset="utf-8" /><title>Codex Preview</title><style>
        :root { color-scheme: light dark; font-family: 'Inter', system-ui, sans-serif; }
        body { margin: 0; padding: 16px; background: #111827; color: #f9fafb; font-size: 14px; line-height: 1.5; }
        section { background: rgba(255,255,255,0.08); border: 1px solid rgba(148, 163, 233, 0.35); border-radius: 16px; padding: 16px; margin-bottom: 16px; backdrop-filter: blur(10px); }
        h1 { margin: 0 0 6px; font-size: 20px; }
        h2 { margin: 0 0 10px; font-size: 16px; text-transform: uppercase; letter-spacing: 0.1em; color: #a5b4fc; }
        p { margin: 0 0 8px; }
        .prompt { white-space: pre-wrap; background: rgba(15,23,42,0.7); border-radius: 12px; padding: 12px; border: 1px solid rgba(96,165,250,0.35); }
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th { text-align: left; padding: 8px 10px; width: 140px; color: #cbd5f5; vertical-align: top; }
        td { padding: 8px 10px; border-bottom: 1px solid rgba(148, 163, 233, 0.25); }
        tr:last-child td { border-bottom: none; }
        .row-head { display: flex; gap: 8px; align-items: center; margin-bottom: 6px; }
        .req { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 999px; background: rgba(59,130,246,0.2); color: #bfdbfe; font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; }
        .req.optional { background: rgba(148,163,233,0.12); color: #e5e7eb; }
        .type { font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; color: #c7d2fe; }
        .limits { display: inline-block; margin-top: 4px; font-size: 11px; color: #e0e7ff; }
        .fields { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
        .fields article { background: rgba(15,23,42,0.65); border-radius: 12px; padding: 12px; border: 1px solid rgba(129,140,248,0.35); display: grid; gap: 6px; }
        .fields footer { font-size: 11px; color: #cbd5f5; text-transform: uppercase; letter-spacing: 0.08em; }
      </style></head><body>
        <section>
          <h1>${escapeHTML(data?.title || 'Codex Entry')}</h1>
          <p><strong>ID:</strong> ${escapeHTML(data?.id || '—')}</p>
        </section>
        <section>
          <h2>Prompt Blueprint</h2>
          <div class="prompt">${escapeHTML(data?.prompt || '')}</div>
        </section>
        <section>
          <h2>Schema</h2>
          ${propertyRows ? `<table>${propertyRows}</table>` : '<p>No schema properties defined.</p>'}
        </section>
        <section>
          <h2>Fields</h2>
          ${fieldCards || '<p>No structured fields configured.</p>'}
        </section>
      </body></html>`;
    }

    function refreshCodexPreview() {
      if (!codexPreviewEl) return;
      codexPreviewEl.srcdoc = buildCodexPreviewDocument(codexModel);
    }

    function parseCodexSource() {
      if (!codexSourceEl) return { ok: false, error: 'Codex editor not available.' };
      const raw = codexSourceEl.value.trim();
      if (!raw) return { ok: false, error: 'Codex JSON is empty.' };
      try {
        return { ok: true, data: JSON.parse(raw) };
      } catch (error) {
        return { ok: false, error: error.message };
      }
    }

    function validateCodexData(data) {
      const errors = [];
      if (!data || typeof data !== 'object' || Array.isArray(data)) {
        errors.push('Document must be a JSON object');
        return { valid: false, errors };
      }
      ['id', 'title', 'prompt'].forEach((key) => {
        if (typeof data[key] !== 'string' || !data[key].trim()) {
          errors.push(`${key} must be a non-empty string`);
        }
      });
      const schema = data.schema;
      if (!schema || typeof schema !== 'object' || Array.isArray(schema)) {
        errors.push('schema must be an object');
      } else {
        if (schema.type !== 'object') {
          errors.push('schema.type must be "object"');
        }
        if (!schema.properties || typeof schema.properties !== 'object') {
          errors.push('schema.properties must be an object');
        } else {
          Object.entries(schema.properties).forEach(([key, prop]) => {
            if (!prop || typeof prop !== 'object' || Array.isArray(prop)) {
              errors.push(`schema.properties.${key} must be an object`);
              return;
            }
            if (!prop.type) {
              errors.push(`schema.properties.${key} requires a type`);
            }
          });
        }
        if (schema.required !== undefined) {
          if (!Array.isArray(schema.required)) {
            errors.push('schema.required must be an array of strings');
          } else {
            schema.required.forEach((req) => {
              if (typeof req !== 'string' || !req.trim()) {
                errors.push('schema.required values must be non-empty strings');
              } else if (!schema.properties || !schema.properties[req]) {
                errors.push(`schema.required contains "${req}" but no matching property was found`);
              }
            });
          }
        }
      }
      if (data.fields !== undefined) {
        if (!Array.isArray(data.fields)) {
          errors.push('fields must be an array');
        } else {
          data.fields.forEach((field, index) => {
            if (!field || typeof field !== 'object') {
              errors.push(`fields[${index}] must be an object`);
              return;
            }
            if (typeof field.id !== 'string' || !field.id.trim()) {
              errors.push(`fields[${index}].id must be a non-empty string`);
            }
            if (typeof field.label !== 'string' || !field.label.trim()) {
              errors.push(`fields[${index}].label must be a non-empty string`);
            }
          });
        }
      }
      return { valid: errors.length === 0, errors };
    }

    function hidePromptSuggestions() {
      if (!codexSuggestionsEl) return;
      codexSuggestionsEl.hidden = true;
      codexSuggestionsEl.innerHTML = '';
    }

    function applyPromptSuggestion(text) {
      if (!codexPromptEl) return;
      codexPromptEl.value = text;
      promptDirty = false;
      codexModel.prompt = text;
      hidePromptSuggestions();
      updateCodexStatus('Applied prompt suggestion. Save to refresh preview.', 'info');
    }

    function updatePromptSuggestions(query) {
      if (!codexSuggestionsEl) return;
      const needle = query.trim().toLowerCase();
      const matches = needle
        ? promptTemplates.filter((item) => item.toLowerCase().includes(needle)).slice(0, 6)
        : promptTemplates.slice(0, 4);
      if (!matches.length || (!needle && !(codexPromptEl && codexPromptEl === document.activeElement))) {
        hidePromptSuggestions();
        return;
      }
      codexSuggestionsEl.innerHTML = '';
      matches.forEach((suggestion, index) => {
        const li = document.createElement('li');
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = suggestion;
        btn.dataset.value = suggestion;
        btn.setAttribute('role', 'option');
        btn.id = `codex-suggestion-${index}`;
        li.appendChild(btn);
        codexSuggestionsEl.appendChild(li);
      });
      codexSuggestionsEl.hidden = false;
    }

    if (codexSuggestionsEl) {
      codexSuggestionsEl.addEventListener('click', (event) => {
        const target = event.target.closest('button[data-value]');
        if (!target) return;
        event.preventDefault();
        applyPromptSuggestion(target.dataset.value);
      });
      codexSuggestionsEl.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          hidePromptSuggestions();
          codexPromptEl?.focus();
        }
      });
    }

    if (codexPromptEl) {
      codexPromptEl.addEventListener('focus', () => {
        updatePromptSuggestions(codexPromptEl.value);
      });
      codexPromptEl.addEventListener('input', () => {
        promptDirty = true;
        codexModel.prompt = codexPromptEl.value;
        updatePromptSuggestions(codexPromptEl.value);
        updateCodexStatus('Prompt updated. Save to apply changes.', 'info');
      });
      codexPromptEl.addEventListener('keydown', (event) => {
        if (!codexSuggestionsEl || codexSuggestionsEl.hidden) return;
        if (event.key === 'ArrowDown') {
          const first = codexSuggestionsEl.querySelector('button');
          if (first) {
            event.preventDefault();
            first.focus();
          }
        } else if ((event.key === 'Enter' || event.key === 'Tab') && !event.shiftKey) {
          const first = codexSuggestionsEl.querySelector('button');
          if (first) {
            event.preventDefault();
            applyPromptSuggestion(first.dataset.value);
          }
        }
      });
      codexPromptEl.addEventListener('blur', () => {
        setTimeout(() => hidePromptSuggestions(), 120);
      });
    }

    if (codexSourceEl) {
      let parseTimer = null;
      codexSourceEl.addEventListener('input', () => {
        if (parseTimer) clearTimeout(parseTimer);
        parseTimer = setTimeout(() => {
          const parsed = parseCodexSource();
          if (parsed.ok) {
            if (!promptDirty && codexPromptEl && typeof parsed.data.prompt === 'string') {
              codexPromptEl.value = parsed.data.prompt;
            }
            updateCodexStatus('Draft parsed. Save to run schema validation.', 'info');
          } else {
            updateCodexStatus(`JSON parse error: ${parsed.error}`, 'error');
          }
        }, 380);
      });
    }

    function handleCodexFormat() {
      const parsed = parseCodexSource();
      if (!parsed.ok) {
        updateCodexStatus(`Cannot format: ${parsed.error}`, 'error');
        return;
      }
      const next = cloneCodex(parsed.data);
      if (codexPromptEl) {
        next.prompt = codexPromptEl.value.trim() || next.prompt || '';
      }
      const validation = validateCodexData(next);
      loadCodexModel(next);
      updatePromptSuggestions('');
      if (validation.valid) {
        updateCodexStatus('Codex formatted. Validation passed.', 'success');
      } else {
        updateCodexStatus(`Format complete with validation issues: ${validation.errors.join(' · ')}`, 'error');
      }
    }

    function handleCodexSave() {
      const parsed = parseCodexSource();
      if (!parsed.ok) {
        updateCodexStatus(`Save failed: ${parsed.error}`, 'error');
        return;
      }
      const next = cloneCodex(parsed.data);
      if (codexPromptEl) {
        next.prompt = codexPromptEl.value.trim() || next.prompt || '';
      }
      const validation = validateCodexData(next);
      if (!validation.valid) {
        updateCodexStatus(`Validation failed: ${validation.errors.join(' · ')}`, 'error');
        return;
      }
      loadCodexModel(next);
      refreshCodexPreview();
      updatePromptSuggestions('');
      updateCodexStatus('Codex saved. Preview refreshed.', 'success');
    }

    if (codexFormatBtn) codexFormatBtn.addEventListener('click', handleCodexFormat);
    if (codexSaveBtn) codexSaveBtn.addEventListener('click', handleCodexSave);

    if (visitorFormEl) {
      visitorFormEl.addEventListener('submit', (event) => {
        event.preventDefault();
        if (!visitorMessageEl) return;
        const note = visitorMessageEl.value.trim();
        if (!note) {
          updateVisitorStatus('Please add a short note before sending.', 'error');
          visitorMessageEl.focus();
          return;
        }
        updateVisitorStatus('Noting your message…');
        const submitBtn = visitorSubmitEl || visitorFormEl.querySelector('button[type="submit"]');
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.setAttribute('aria-busy', 'true');
        }
        window.setTimeout(() => {
          console.log('[Codex visitor note]', note);
          visitorFormEl.reset();
          updateVisitorStatus('Message received. Thanks for contributing!', 'success');
          if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.removeAttribute('aria-busy');
          }
        }, 360);
      });
    }

    document.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 's') {
        const active = document.activeElement;
        if (active === codexSourceEl || active === codexPromptEl) {
          event.preventDefault();
          handleCodexSave();
        }
      }
    });

    if (codexPreviewEl) {
      codexPreviewEl.addEventListener('load', () => {
        codexPreviewEl.setAttribute('aria-live', 'polite');
      });
    }

    loadCodexModel(defaultCodexDocument);
    refreshCodexPreview();
    updatePromptSuggestions('');
    updateCodexStatus('Codex workspace ready. Modify the JSON and save to refresh the preview.', 'info');

    /* ============================================================
       MODAL (tooltip-style info + slider)
    ============================================================ */
    const dlg = el('#infoModal');
    const mTitle = el('#mTitle');
    const mDef = el('#mDef');
    const mBrain = el('#mBrain');
    const mNT = el('#mNT');
    const mEnergy = el('#mEnergy');
    const mStage = el('#mStage');
    const mSlider = el('#mSlider');
    const mActVal = el('#mActVal');
    const mSummary = el('#mSummary');

    let currentAspect = null;

    function openModal(a) {
      currentAspect = a;
      mTitle.textContent = a.name;
      if (mode==='mind') {
        mDef.textContent = a.definition;
        mBrain.textContent = a.nsilSemanticSignature || '—';
        mNT.textContent = `${a.quantumMode || '—'} · ${a.particleWaveFieldFunction || ''}`;
        mEnergy.textContent = `${a.semanticGravity || '—'}`;
        mStage.textContent = `Stage ${a.stage} · Ring ${a.ring}`;
      } else if (mode==='body') {
        mDef.textContent = a.definition;
        mBrain.innerHTML = describeBrain(a.brainRegionKey, a.brainRegion);
        mNT.innerHTML = describeNeurochemical(a.neurotransmitterKey, a.neurotransmitter);
        mEnergy.innerHTML = describeMode(a.energyModeKey, a.energyMode);
        mStage.textContent = `Stage ${a.stage} · Ring ${a.ring}`;
      } else {
        mDef.textContent = a.definition;
        mBrain.textContent = a.archetypalSymbol || '—';
        mNT.textContent = a.spiritualRole || '—';
        mEnergy.textContent = a.nsilPrincipleSignature || '—';
        mStage.textContent = `Stage ${a.stage} · Ring ${a.ring}`;
      }
      mSlider.value = String(a.activation);
      mActVal.textContent = String(a.activation);
      updateModalSummary();
      dlg.showModal();
    }

    function updateModalSummary() {
      if (!currentAspect) return;
      const energyIn = currentAspect.activation;
      const region = currentAspect.brainRegion || '—';
      const ntStr = String(currentAspect.neurotransmitter || '—');
      const neuroOut = ntStr.split(' ')[0];
      const metabolic = Math.round((energyIn/100) * 100);
      mSummary.textContent = `Energy in: ${energyIn} → ${region} → NT: ${neuroOut} → functional output: ${currentAspect.matterOutput || '—'} (metabolic load ≈ ${metabolic}%)`;
    }

    dlg.addEventListener('close', ()=>{ currentAspect = null; });
    dlg.addEventListener('click', (e)=>{
      const rect = dlg.getBoundingClientRect();
      if (e.clientY < rect.top || e.clientY > rect.bottom || e.clientX < rect.left || e.clientX > rect.right) dlg.close();
    });
    dlg.querySelector('button[value="cancel"]').addEventListener('click', ()=> dlg.close());
    mSlider.addEventListener('input', (e) => {
      if (!currentAspect) return;
      currentAspect.activation = Number(e.target.value);
      mActVal.textContent = String(currentAspect.activation);
      updateModalSummary();
      const row = listEl.querySelector(`[data-id="${currentAspect.id}"]`);
      if (row) {
        const label = row.querySelector('label');
        const range = row.querySelector('input[type="range"]');
        const bar = row.querySelector('.activation-bar span');
        if (range) range.value = String(currentAspect.activation);
        if (label) label.textContent = `Activation: ${currentAspect.activation}`;
        if (bar) bar.style.width = `${currentAspect.activation}%`;
      }
      draw();
      updateMetrics();
    });

    /* ============================================================
       CANVAS RENDERING
    ============================================================ */
    const canvas = el('#clock');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const { clientWidth:w, clientHeight:h } = canvas;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      center.x = w/2; center.y = h/2;
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    function polar(angle, radius) {
      return { x: center.x + Math.cos(angle)*radius, y: center.y + Math.sin(angle)*radius };
    }

    function drawRings(maxR) {
      const rings = 8;
      const step = maxR / rings;
      ctx.save();
      ctx.lineWidth = 1;
      for (let i=1;i<=rings;i++) {
        ctx.beginPath();
        ctx.strokeStyle = (i % 2 ? palette.ring1 : palette.ring2) || '#1a214a';
        ctx.arc(center.x, center.y, step*i, 0, TWO_PI);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawStageLines(maxR) {
      const count = 12;
      ctx.save();
      ctx.strokeStyle = palette.stage || '#24306f';
      ctx.lineWidth = 1;
      for (let s=0; s<count; s++) {
        const angle = (s/count)*TWO_PI - Math.PI/2;
        const p1 = polar(angle, 10);
        const p2 = polar(angle, maxR);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawNodes(maxR) {
      const nodeR = 10;
      const radius = maxR * 0.92;
      const out = [];
      aspects.forEach((a, i) => {
        const angle = (i/N_ASPECTS)*TWO_PI - Math.PI/2;
        const p = polar(angle, radius);
        const arcSize = Math.max(0.05, a.activation/100) * (TWO_PI / N_ASPECTS);
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, angle - arcSize/2, angle + arcSize/2);
        ctx.strokeStyle = hsl(a.hue, 70, 55);
        ctx.lineWidth = 8;
        ctx.globalAlpha = 0.55;
        ctx.stroke();
        ctx.globalAlpha = 1;

        ctx.beginPath();
        ctx.fillStyle = hsl(a.hue, 70, 50);
        ctx.arc(p.x, p.y, nodeR, 0, TWO_PI);
        ctx.fill();
        ctx.lineWidth = (a.id === state.focusId) ? 3 : 1.5;
        ctx.strokeStyle = (a.id === state.focusId) ? (palette.focus || '#fde68a') : (palette.nodeBorder || '#0b0f2a');
        ctx.stroke();

        ctx.fillStyle = palette.label || '#cbd5f1';
        ctx.font = '12px "Inter", system-ui, -apple-system, Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText(a.name, p.x, p.y - (nodeR+8));

        out.push({ id: a.id, x: p.x, y: p.y, angle });
      });
      return out;
    }

    function drawResonanceLinks(nodePoints) {
      ctx.save();
      ctx.lineCap = 'round';
      for (let i=0;i<aspects.length;i++) {
        for (let j=i+1;j<aspects.length;j++) {
          const ai = aspects[i], aj = aspects[j];
          const sim = Math.abs(ai.activation - aj.activation);
          const sameStage = (ai.stage === aj.stage);
          const sameRing = (ai.ring === aj.ring);
          const shouldLink = sim <= state.resonanceThreshold || sameStage || sameRing;
          if (!shouldLink) continue;
          const pi = nodePoints[i], pj = nodePoints[j];
          const d = Math.hypot(pi.x - pj.x, pi.y - pj.y);
          const alpha = Math.min(0.35, 0.08 + (1 - sim/100) * 0.25) * (sameStage ? 1.25 : 1) * (sameRing ? 1.15 : 1);
          ctx.beginPath();
          const grad = ctx.createLinearGradient(pi.x, pi.y, pj.x, pj.y);
          grad.addColorStop(0, palette.resonanceA || '#34d399');
          grad.addColorStop(1, palette.resonanceB || '#7dd3fc');
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = grad;
          ctx.lineWidth = Math.max(0.5, 2.5 - (d/260));
          ctx.moveTo(pi.x, pi.y);
          ctx.lineTo(pj.x, pj.y);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
      ctx.restore();
    }

    function drawTutorialHalo(nodePoints) {
      if (!state.tutorial) return;
      const idx = (state.tutorialIndex % aspects.length);
      const { x, y } = nodePoints[idx];
      const t = performance.now()/1000;
      const pulse = 10 + 6*Math.sin(t*2);
      ctx.save();
      const g = ctx.createRadialGradient(x, y, 2, x, y, 42+pulse);
      g.addColorStop(0, 'rgba(245, 158, 11, 0.7)');
      g.addColorStop(1, 'rgba(245, 158, 11, 0.0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, 42+pulse, 0, TWO_PI);
      ctx.fill();
      ctx.restore();
    }

    function draw() {
      const { width:w, height:h } = canvas;
      ctx.clearRect(0,0,w,h);
      const maxR = Math.min(w, h)/2 - 30;
      drawRings(maxR);
      drawStageLines(maxR);
      const points = drawNodes(maxR);
      drawResonanceLinks(points);
      drawTutorialHalo(points);
    }

    // Animation loop for tutorial halo
    function tick() { if (state.tutorial) draw(); requestAnimationFrame(tick); }

    /* ============================================================
       HIT TEST & INTERACTION (mouse/touch)
    ============================================================ */
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    function nodeAt(x, y) {
      const { width:w, height:h } = canvas;
      const maxR = Math.min(w, h)/2 - 30; const radius = maxR * 0.92; const nodeR = 12;
      for (let i=0;i<aspects.length;i++) {
        const angle = (i/N_ASPECTS)*TWO_PI - Math.PI/2;
        const p = polar(angle, radius);
        if (Math.hypot(x - p.x, y - p.y) <= nodeR+2) return aspects[i];
      }
      return null;
    }

    canvas.addEventListener('click', (e)=>{
      const p = getMousePos(e);
      const a = nodeAt(p.x, p.y);
      if (a) { state.focusId = a.id; refreshListSelection(); draw(); openModal(a); }
    });

    // Basic keyboard navigation
    window.addEventListener('keydown', (e)=>{
      const key = e.key.toLowerCase();
      if (key === 't') { e.preventDefault(); toggleTutorial(); }
      if (key === 'r') { e.preventDefault(); randomize(); }
      if (key === 'e') { e.preventDefault(); openExportDialog(); }
      if (key === '0') { e.preventDefault(); deactivateAll(); }
      if (key === 'arrowright' || key === 'arrowdown') { e.preventDefault(); moveFocus(1); }
      if (key === 'arrowleft' || key === 'arrowup') { e.preventDefault(); moveFocus(-1); }
      if (key === 'enter') { e.preventDefault(); const a = aspects.find(x=>x.id===state.focusId); if (a) openModal(a); }
    });

    function moveFocus(delta) {
      const pool = (state.visible && state.visible.length) ? state.visible : aspects;
      if (!pool.length) return;
      let idx = pool.findIndex(a => a.id === state.focusId);
      if (idx === -1) idx = 0;
      const next = (idx + delta + pool.length) % pool.length;
      state.focusId = pool[next].id;
      refreshListSelection();
      draw();
      const row = listEl.querySelector(`[data-id="${state.focusId}"]`);
      row?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    /* ============================================================
       COMMANDS & EXPORT
    ============================================================ */
    function randomize() {
      aspects.forEach(a => a.activation = Math.round(Math.random()*100));
      updateMetrics();
      buildList();
      draw();
    }

    function deactivateAll() {
      aspects.forEach(a => a.activation = 0);
      updateMetrics();
      buildList();
      draw();
    }

    // Build payload separately so we can unit-test it
    function buildExportPayload() {
      const metrics = computeSCI();
      const { total, byNT, metabolic } = computeEnergyMatter();
      return {
        generatedAt: new Date().toISOString(),
        model: `32 Aspect Developmental Self Clock — ${mode}`,
        devStage: state.devStage,
        devStageLabel: stageLabel(state.devStage),
        stageWeights: [...state.stageWeights],
        metrics: {
          mean: metrics.mean,
          std: metrics.std,
          sci: metrics.sci,
          activationScore: metrics.activationScore,
          balance: metrics.balance,
          resonanceRatio: metrics.resonanceScore,
          alignmentScore: metrics.alignmentScore,
          formula: formatSciFormula(metrics)
        },
        resonance: metrics.resonance,
        energyMatter: { total, byNT: Object.fromEntries(byNT), metabolic },
        filters: {
          search: state.filterText,
          sort: state.sort,
          stage: state.stageFilter,
          ring: state.ringFilter,
          activeOnly: state.activeOnly,
        },
        comparison: {
          stageA: Number(compareStageA?.value ?? state.devStage),
          stageB: Number(compareStageB?.value ?? state.devStage),
          summary: comparisonSummaryEl ? comparisonSummaryEl.textContent : '',
          summaryHtml: comparisonSummaryEl ? comparisonSummaryEl.innerHTML : ''
        },
        aspects: aspects.map(a => ({ ...a }))
      };
    }

    function downloadFile(content, mime, filename) {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function registerDialogBackdropClose(dialogEl, onClose) {
      if (!dialogEl) return;
      dialogEl.addEventListener('click', (event) => {
        const rect = dialogEl.getBoundingClientRect();
        if (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom) {
          dialogEl.close();
        }
      });
      if (typeof onClose === 'function') dialogEl.addEventListener('close', onClose);
    }

    function exportJSON() {
      const payload = buildExportPayload();
      downloadFile(JSON.stringify(payload, null, 2), 'application/json', 'self-clock-export.json');
    }

    function csvEscape(value) {
      const str = String(value ?? '');
      if (/[",\n]/.test(str)) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      return str;
    }

    function exportCSV() {
      const payload = buildExportPayload();
      const header = ['Aspect', 'Stage', 'Ring', 'Activation', 'Base', 'Brain', 'Neurotransmitter', 'Mode'];
      const rows = [header.join(',')];
      payload.aspects.forEach(a => {
        rows.push([
          csvEscape(a.name),
          csvEscape(a.stage),
          csvEscape(a.ring),
          csvEscape(a.activation),
          csvEscape(a.baseActivation ?? (a.devProfile?.[state.devStage] ?? '')),
          csvEscape(a.brainRegion || a.brainRegionKey || '—'),
          csvEscape(a.neurotransmitter || a.neurotransmitterKey || '—'),
          csvEscape(a.energyMode || a.energyModeKey || '—')
        ].join(','));
      });
      downloadFile(rows.join('\n'), 'text/csv', 'self-clock-export.csv');
    }

    function escapeHtml(str) {
      return String(str ?? '').replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch]));
    }

    function exportReport() {
      const payload = buildExportPayload();
      const topAspects = payload.aspects.slice().sort((a,b)=>b.activation - a.activation).slice(0,8);
      const rows = topAspects.map(a => `<tr><td>${escapeHtml(a.name)}</td><td>${a.activation}</td><td>${escapeHtml(a.brainRegion || a.brainRegionKey || '—')}</td><td>${escapeHtml(a.neurotransmitter || a.neurotransmitterKey || '—')}</td></tr>`).join('');
      const html = `<!doctype html><html><head><meta charset="utf-8"><title>Self Clock Report</title><style>
        body{font-family:Inter,Segoe UI,sans-serif;background:#f5f7ff;color:#111827;padding:32px;line-height:1.6;}
        h1{margin-top:0;}
        table{border-collapse:collapse;width:100%;margin-top:16px;}
        th,td{border:1px solid #cbd5f5;padding:8px;text-align:left;}
        th{background:#e0e7ff;}
        .muted{color:#6b7280;font-size:14px;}
      </style></head><body>
        <h1>32 Aspect Developmental Self Clock</h1>
        <p class="muted">Generated ${escapeHtml(new Date().toLocaleString())}</p>
        <h2>Semantic Coherence Index</h2>
        <p><strong>${payload.metrics.sci.toFixed(1)}</strong> · ${escapeHtml(payload.metrics.formula)}</p>
        <p>Resonance coverage ${(payload.metrics.resonanceRatio*100).toFixed(0)}% across ${payload.resonance.supportive}/${payload.resonance.total} potential links.</p>
        <h2>Developmental Context</h2>
        <p>Active stage: <strong>${escapeHtml(payload.devStageLabel)}</strong>. Stage weights: ${payload.stageWeights.map((w,i)=>`Stage ${i+1} ${Number(w).toFixed(2)}×`).join(', ')}.</p>
        <p>${payload.comparison.summaryHtml || escapeHtml(payload.comparison.summary || '')}</p>
        <h2>Energy–Matter</h2>
        <p>Total activation ${Math.round(payload.energyMatter.total)} · Metabolic ${(payload.energyMatter.metabolic*100).toFixed(0)}%</p>
        <h2>Peak Activations</h2>
        <table><thead><tr><th>Aspect</th><th>Activation</th><th>Brain</th><th>Neurochemical</th></tr></thead><tbody>${rows}</tbody></table>
      </body></html>`;
      downloadFile(html, 'text/html', 'self-clock-report.html');
    }

    function openExportDialog() {
      if (exportDialog && !exportDialog.open) exportDialog.showModal();
    }

    /* ============================================================
       TUTORIAL / WALKTHROUGH MODE
    ============================================================ */
    let tutorialTimer = null;
    function toggleTutorial(forceValue) {
      const next = typeof forceValue === 'boolean' ? forceValue : !state.tutorial;
      if (state.tutorial === next) {
        if (next && tutorialDialog && !tutorialDialog.open) tutorialDialog.showModal();
        return;
      }
      state.tutorial = next;
      if (tutorialBtn) {
        tutorialBtn.setAttribute('aria-pressed', String(state.tutorial));
        tutorialBtn.textContent = state.tutorial ? '⏸ Tutorial' : '▶ Tutorial';
      }
      if (state.tutorial) {
        if (!tutorialTimer) tutorialTimer = setInterval(()=>{
          state.tutorialIndex = (state.tutorialIndex + 1) % aspects.length;
          state.focusId = aspects[state.tutorialIndex].id;
          refreshListSelection(); draw();
        }, 1400);
        if (tutorialDialog && !tutorialDialog.open) tutorialDialog.showModal();
      } else {
        clearInterval(tutorialTimer); tutorialTimer = null; draw();
        if (tutorialDialog && tutorialDialog.open) tutorialDialog.close();
      }
    }

    /* ============================================================
       UI WIRING
    ============================================================ */
    tutorialBtn?.addEventListener('click', ()=> toggleTutorial());
    el('#btnRandomize').addEventListener('click', randomize);
    el('#btnDeactivate').addEventListener('click', deactivateAll);
    exportBtn?.addEventListener('click', (e)=> { e.preventDefault(); openExportDialog(); });

    function attachExportHandler(btn, handler) {
      if (!btn) return;
      btn.addEventListener('click', (event)=> {
        event.preventDefault();
        handler();
        exportDialog?.close();
      });
    }

    attachExportHandler(exportJsonBtn, exportJSON);
    attachExportHandler(exportCsvBtn, exportCSV);
    attachExportHandler(exportReportBtn, exportReport);

    if (sciInfoBtn) sciInfoBtn.addEventListener('click', ()=> {
      if (sciFormulaEl) sciFormulaEl.textContent = formatSciFormula(computeSCI());
      if (sciModal && !sciModal.open) sciModal.showModal();
    });

    registerDialogBackdropClose(sciModal);
    registerDialogBackdropClose(tutorialDialog, ()=> { if (state.tutorial) toggleTutorial(false); });
    registerDialogBackdropClose(exportDialog);

    function setMode(newMode){
      mode = newMode;
      aspects = (mode==='mind') ? mindAspects : (mode==='body') ? bodyAspects : soulAspects;
      el('#modeMind').classList.toggle('secondary', mode!=='mind');
      el('#modeBody').classList.toggle('secondary', mode!=='body');
      el('#modeSoul').classList.toggle('secondary', mode!=='soul');
      el('#modeMind').setAttribute('aria-pressed', String(mode==='mind'));
      el('#modeBody').setAttribute('aria-pressed', String(mode==='body'));
      el('#modeSoul').setAttribute('aria-pressed', String(mode==='soul'));
      buildList();
      applyDevStage(state.devStage);
      updateMetrics();
      draw();
    }

    el('#modeMind').addEventListener('click', ()=> setMode('mind'));
    el('#modeBody').addEventListener('click', ()=> setMode('body'));
    el('#modeSoul').addEventListener('click', ()=> setMode('soul'));

    /* ============================================================
       SELF-TESTS (basic runtime checks) — shown in console
       We add tests since none existed previously.
    ============================================================ */
    function runSelfTests() {
      const results = [];
      function assert(name, cond) { results.push({ name, pass: !!cond }); }

      // Test 1: DEV_STAGES
      assert('DEV_STAGES == 12', DEV_STAGES === 12);

      // Test 2: Each dataset has 32 aspects
      assert('mindAspects length', mindAspects.length === 32);
      assert('bodyAspects length', bodyAspects.length === 32);
      assert('soulAspects length', soulAspects.length === 32);

      // Test 3: devProfile lengths
      assert('mind devProfile[0].length == 12', mindAspects[0].devProfile.length === 12);

      // Test 4: SCI on uniform activations → high coherence, variance ≈ 0
      const bak = aspects;
      aspects = [
        { activation: 50, stage: 1, ring: 1 },
        { activation: 50, stage: 1, ring: 1 },
        { activation: 50, stage: 1, ring: 1 },
        { activation: 50, stage: 1, ring: 1 }
      ];
      const { mean, std, sci, resonance } = computeSCI();
      assert('SCI std == 0', Math.abs(std - 0) < 1e-9);
      assert('SCI resonance == 1', Math.abs(resonance.ratio - 1) < 1e-9);
      assert('SCI value', Math.abs(sci - 82.5) < 1e-6);
      aspects = bak;

      // Test 5: export payload shape
      const payload = buildExportPayload();
      assert('payload.aspects length == 32', Array.isArray(payload.aspects) && payload.aspects.length === 32);
      assert('payload.metrics has sci', typeof payload.metrics.sci === 'number');
      assert('payload.metrics has formula', typeof payload.metrics.formula === 'string');

      // Report
      const passCount = results.filter(r=>r.pass).length;
      const fail = results.filter(r=>!r.pass);
      console.log('%cSelf-tests:', 'font-weight:bold');
      results.forEach(r=> console.log(r.pass ? '✅' : '❌', r.name));
      if (fail.length) {
        console.warn('Some self-tests failed:', fail);
      } else {
        console.log(`All ${passCount} self-tests passed.`);
      }
    }

    const layoutQuery = window.matchMedia ? window.matchMedia('(max-width: 900px)') : { matches: false };
    const handleLayout = (ev) => applyLayoutMode(ev.matches);
    if (layoutQuery.addEventListener) {
      layoutQuery.addEventListener('change', handleLayout);
    } else if (layoutQuery.addListener) {
      layoutQuery.addListener(handleLayout);
    }
    applyLayoutMode(layoutQuery.matches);
    updatePanelToggleLabel();

    // Initial build & draw
    const initialTheme = detectInitialTheme();
    applyTheme(initialTheme);
    resizeCanvas();
    applyDevStage(state.devStage);
    requestAnimationFrame(tick);
    runSelfTests();

    /* ============================================================
       SCIENCE NOTES (for researchers inside code comments)
       ----------------------------------------------------
       • SCI blends activation power, variance balance, and resonance/structure
         alignment: 0.35·activation + 0.35·balance + 0.20·resonance +
         0.10·alignment.
       • We visualize C = E × MC (concept → energy × matter × cognition) via
         the info modal's pipeline description and resonance links.
       • 12 radial cross-lines = expanded Erikson-like developmental stages; 
         use your mapping to stage names in your dataset if available.
       • 8 concentric rings = anatomy/energy zones; link to somatic/energetic
         layers (e.g., brainstem → cortex, fascia layers, chakric analogues).
       • Resonance edges connect nodes with similar activation OR sharing
         stage/ring, encoding feedback/overlap and nonlinearity.
       • Tutorial traces a simple loop through aspects. For research demos,
         extend by adding causal/feedback animations (mind→body→action→mind).
       • Accessibility: All controls are reachable by keyboard; modal is a
         native <dialog>; listbox items are focusable and announce changes.
    ============================================================ */
  </script>
</body>
</html>
